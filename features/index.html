<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Less extends CSS with dynamic behavior such as variables, mixins, operations and functions. Less runs on both the server-side (with Node.js and Rhino) or client-side (modern browsers only).
">
<meta name="author" content="The Core Less Team">

<title>
  Features In-Depth | Less.js
</title>

<link href="https://fonts.googleapis.com/css?family=Noto+Serif|Oxygen" rel="stylesheet">

<!-- Algolia DocSearch styles -->
<link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@docsearch/css@3">

<!-- Main styles -->
<link href="../public/css/index.css" rel="stylesheet">

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
  <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<!-- Favicons -->
<link rel="shortcut icon" href="../public/ico/favicon.ico">

  </head>
  <body class="features">

    
    
    
    <div class="container docs-container">
      <div class="row">
        <div class="col-md-3">
          <div class="sidebar hidden-print" role="complementary">
            <div id="navigation">
  
<ul class="nav sidenav"><li><a href="#features-overview-feature">Overview</a></li>
<li><a href="#variables-feature">Variables</a><ul class="nav"><li><a href="#variables-feature-overview">Overview</a></li>
<li><a href="#variables-feature-variable-interpolation">Variable Interpolation</a></li>
<li><a href="#variables-feature-variable-variables">Variable Variables</a></li>
<li><a href="#variables-feature-lazy-evaluation">Lazy Evaluation</a></li>
<li><a href="#variables-feature-properties-as-variables-new-">Properties as Variables <strong>(NEW!)</strong></a></li>
<li><a href="#variables-feature-default-variables">Default Variables</a></li></ul></li>
<li><a href="#parent-selectors-feature">Parent Selectors</a><ul class="nav"><li><a href="#parent-selectors-feature-multiple-">Multiple <code>&amp;</code></a></li>
<li><a href="#parent-selectors-feature-changing-selector-order">Changing Selector Order</a></li>
<li><a href="#parent-selectors-feature-combinatorial-explosion">Combinatorial Explosion</a></li></ul></li>
<li><a href="#import-atrules-feature">@import At-Rules</a><ul class="nav"><li><a href="#import-atrules-feature-file-extensions">File Extensions</a></li>
<li><a href="#import-atrules-feature-import-options">Import Options</a></li>
<li><a href="#import-atrules-feature-reference">reference</a></li>
<li><a href="#import-atrules-feature-inline">inline</a></li>
<li><a href="#import-atrules-feature-less">less</a></li>
<li><a href="#import-atrules-feature-css">css</a></li>
<li><a href="#import-atrules-feature-once">once</a></li>
<li><a href="#import-atrules-feature-multiple">multiple</a></li>
<li><a href="#import-atrules-feature-optional">optional</a></li></ul></li>
<li><a href="#extend-feature">Extend</a><ul class="nav"><li><a href="#extend-feature-extend-syntax">Extend Syntax</a></li>
<li><a href="#extend-feature-extend-attached-to-selector">Extend Attached to Selector</a></li>
<li><a href="#extend-feature-extend-inside-ruleset">Extend Inside Ruleset</a></li>
<li><a href="#extend-feature-extending-nested-selectors">Extending Nested Selectors</a></li>
<li><a href="#extend-feature-exact-matching-with-extend">Exact Matching with Extend</a></li>
<li><a href="#extend-feature-nth-expression">nth Expression</a></li>
<li><a href="#extend-feature-extend-all">Extend &quot;all&quot;</a></li>
<li><a href="#extend-feature-selector-interpolation-with-extend">Selector Interpolation with Extend</a></li>
<li><a href="#extend-feature-scoping-extend-inside-media">Scoping / Extend Inside @media</a></li>
<li><a href="#extend-feature-duplication-detection">Duplication Detection</a></li>
<li><a href="#extend-feature-use-cases-for-extend">Use Cases for Extend</a></li></ul></li>
<li><a href="#merge-feature">Merge properties</a><ul class="nav"><li><a href="#merge-feature-comma">Comma</a></li>
<li><a href="#merge-feature-space">Space</a></li></ul></li>
<li><a href="#mixins-feature">Mixins</a><ul class="nav"><li><a href="#mixins-feature-mixins-with-parentheses">Mixins With Parentheses</a></li>
<li><a href="#mixins-feature-selectors-in-mixins">Selectors in Mixins</a></li>
<li><a href="#mixins-feature-namespaces">Namespaces</a></li>
<li><a href="#mixins-feature-guarded-namespaces">Guarded Namespaces</a></li>
<li><a href="#mixins-feature-the-important-keyword">The <code>!important</code> keyword</a></li>
<li><a href="#mixins-feature-mixins-parametric-feature">Parametric Mixins</a></li>
<li><a href="#mixins-feature-pattern-matching">Pattern-matching</a></li>
<li><a href="#mixins-feature-mixins-as-functions-feature">Using Mixins as Functions</a></li>
<li><a href="#mixins-feature-loops-feature">Recursive Mixins</a></li>
<li><a href="#mixins-feature-mixin-guards-feature">Mixin Guards</a></li>
<li><a href="#mixins-feature-mixin-aliasing-feature">Aliasing Mixins</a></li></ul></li>
<li><a href="#detached-rulesets-feature">Detached Rulesets</a><ul class="nav"><li><a href="#detached-rulesets-feature-scoping">Scoping</a></li>
<li><a href="#detached-rulesets-feature-property-variable-accessors">Property / variable accessors</a></li></ul></li>
<li><a href="#maps-feature">Maps</a><ul class="nav"><li><a href="#maps-feature-using-variable-variables-in-lookups">Using variable variables in lookups</a></li></ul></li>
<li><a href="#scope-feature">Scope</a><ul class="nav"><li><a href="#scope-feature-mixin-scope-features">Mixin scope features</a></li>
<li><a href="#scope-feature-deprecated-mixin-scope-features">Deprecated mixin scope features</a></li>
<li><a href="#scope-feature-tips-tricks">Tips &amp; Tricks</a></li></ul></li>
<li><a href="#css-guards-feature">CSS Guards</a></li>
<li><a href="#plugin-atrules-feature">@plugin At-Rules</a><ul class="nav"><li><a href="#plugin-atrules-feature-writing-your-first-plugin">Writing your first plugin</a></li>
<li><a href="#plugin-atrules-feature-plugin-scope">Plugin Scope</a></li>
<li><a href="#plugin-atrules-feature-null-functions">Null Functions</a></li>
<li><a href="#plugin-atrules-feature-the-less-js-plugin-object">The Less.js Plugin Object</a></li>
<li><a href="#plugin-atrules-feature-pre-loaded-plugins">Pre-Loaded Plugins</a></li></ul></li></ul></div>
<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CE7IK5QL&amp;placement=lesscssorg" id="_carbonads_js"></script>
          </div>
        </div>
        <div class="col-md-9" role="main">
          
          <header class="navbar navbar-inverse navbar-fixed-top docs-nav" role="banner">
  <div class="container">
    <div class="navbar-header">
      <button class="navbar-toggle" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
      <ul class="nav navbar-nav">
        
        <li>
          <a href="../#">Overview</a>
        </li>
        

        
        <li>
          <a href="../usage/">Using Less.js</a>
        </li>
        

        
        <li>
          <a href="../functions/">Functions</a>
        </li>
        

        
        <li class="active">
          <span>In-Depth Guide</span>
        </li>
        

        

        
        <li>
          <a href="../tools/">Tools</a>
        </li>
        

        
        <li>
          <a href="../about/">About</a>
        </li>
        
       
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        

        <li>
          <div id="docsearch-wrapper">
            <div id="docsearch"></div>
          </div>
        </li>
        
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">GitHub <b class="caret"></b></a>
          <ul class="dropdown-menu">
            <li> <a href="https://github.com/less/less-docs">Docs Repo</a> </li>
            <li> <a href="https://github.com/less/less-docs/issues?&amp;state=open">Docs Issues</a> </li>
            <li class="divider"></li>
            <li> <a href="https://github.com/less/less.js.git">Less Repo</a> </li>
            <li> <a href="https://github.com/less/less.js/issues">Less Issues</a> </li>
          </ul>
        </li>
      </ul>
    </nav>
  </div>
</header>

          
<div class="panel docs-content">
  


  <!-- Overview -->
  <div class="docs-section">
    
    <h1 id="features-overview-feature" class="docs-heading"><span class="anchor-target" id="features-overview-feature"></span>
<a href="#features-overview-feature" name="features-overview-feature" class="anchor glyphicon glyphicon-link"></a>Overview</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/overview.md" data-content="overviewmd" target="_blank"></a>



<a id="overviewmd" href="https://github.com/less/less-docs/blob/master/content/features/overview.md" target="_blank">Edit the markdown source for &quot;overview&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- overview -->
         


        <blockquote>
<p>An in-depth guide to features of the LESS language. See the <a href="/#overview">Overview</a> for a quick summary of Less.</p>
</blockquote>
<p><em>For an in-depth guide to installing and setting up a Less environment, as well as documentation on developing for Less, see: <a href="/usage">Using Less.js</a>.</em></p>


        <br>
      </div>
    

    

  </div>

  <!-- Variables -->
  <div class="docs-section">
    
    <h1 id="variables-feature" class="docs-heading"><span class="anchor-target" id="variables-feature"></span>
<a href="#variables-feature" name="variables-feature" class="anchor glyphicon glyphicon-link"></a>Variables</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/variables.md" data-content="variablesmd" target="_blank"></a>



<a id="variablesmd" href="https://github.com/less/less-docs/blob/master/content/features/variables.md" target="_blank">Edit the markdown source for &quot;variables&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- variables -->
         


        <blockquote>
<p>Control commonly used values in a single location.</p>
</blockquote>
<h3 id="variables-feature-overview" class="docs-heading"><span class="anchor-target" id="variables-feature-overview"></span>
<a href="#variables-feature-overview" name="variables-feature-overview" class="anchor glyphicon glyphicon-link"></a>Overview</h3>
<p>It&apos;s not uncommon to see the same value repeated dozens <em>if not hundreds of times</em> across your stylesheets:</p>
<pre><code class="lang-css"><span class="hljs-tag">a</span>,
<span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#428bca</span>;
}
<span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#fff</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#428bca</span>;
}
</code></pre>
<p>Variables make your code easier to maintain by giving you a way to control those values from a single location:</p>
<pre><code class="lang-less"><span class="hljs-comment">// Variables</span>
<span class="hljs-variable">@link-color:</span>        <span class="hljs-hexcolor">#428bca</span>; <span class="hljs-comment">// sea blue</span>
<span class="hljs-variable">@link-color-hover:</span>  <span class="hljs-function">darken</span>(<span class="hljs-variable">@link-color</span>, <span class="hljs-number">10%</span>);

<span class="hljs-comment">// Usage</span>
<span class="hljs-tag">a</span>,
<span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@link-color</span>;
}
<span class="hljs-tag">a</span><span class="hljs-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@link-color-hover</span>;
}
<span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#fff</span>;
  <span class="hljs-attribute">background</span>: <span class="hljs-variable">@link-color</span>;
}
</code></pre>
<h3 id="variables-feature-variable-interpolation" class="docs-heading"><span class="anchor-target" id="variables-feature-variable-interpolation"></span>
<a href="#variables-feature-variable-interpolation" name="variables-feature-variable-interpolation" class="anchor glyphicon glyphicon-link"></a>Variable Interpolation</h3>
<p>The examples above focused on using variables to control <em>values in CSS rules</em>, but they can also be used in other places as well, such as selector names, property names, URLs and <code>@import</code> statements.</p>
<h4 id="variables-feature-selectors" class="docs-heading"><span class="anchor-target" id="variables-feature-selectors"></span>
<a href="#variables-feature-selectors" name="variables-feature-selectors" class="anchor glyphicon glyphicon-link"></a>Selectors</h4>
<p><em>v1.4.0</em></p>
<pre><code class="lang-less"><span class="hljs-comment">// Variables</span>
<span class="hljs-variable">@my-selector:</span> banner;

<span class="hljs-comment">// Usage</span>
<span class="hljs-class">.@{my-selector}</span> {
  <span class="hljs-attribute">font-weight</span>: bold;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
}
</code></pre>
<p>Compiles to:</p>
<pre><code class="lang-css"><span class="hljs-class">.banner</span> {
  <span class="hljs-attribute">font-weight</span>: bold;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;
}
</code></pre>
<h4 id="variables-feature-urls" class="docs-heading"><span class="anchor-target" id="variables-feature-urls"></span>
<a href="#variables-feature-urls" name="variables-feature-urls" class="anchor glyphicon glyphicon-link"></a>URLs</h4>
<pre><code class="lang-less"><span class="hljs-comment">// Variables</span>
<span class="hljs-variable">@images:</span> <span class="hljs-string">&quot;../img&quot;</span>;

<span class="hljs-comment">// Usage</span>
<span class="hljs-tag">body</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#444</span>;
  <span class="hljs-attribute">background</span>: url(<span class="hljs-string">&quot;@{images}/white-sand.png&quot;</span>);
}
</code></pre>
<h4 id="variables-feature-import-statements" class="docs-heading"><span class="anchor-target" id="variables-feature-import-statements"></span>
<a href="#variables-feature-import-statements" name="variables-feature-import-statements" class="anchor glyphicon glyphicon-link"></a>Import Statements</h4>
<p><em>v1.4.0</em></p>
<p>Syntax: <code>@import &quot;@{themes}/tidal-wave.less&quot;;</code></p>
<p>Note that before v2.0.0, only variables which have been declared in the root or current scope were considered and that only the current file and calling files were considered when looking for a variable.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-comment">// Variables</span>
<span class="hljs-variable">@themes:</span> <span class="hljs-string">&quot;../../src/themes&quot;</span>;

<span class="hljs-comment">// Usage</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;@{themes}/tidal-wave.less&quot;</span>;
</code></pre>
<h4 id="variables-feature-properties" class="docs-heading"><span class="anchor-target" id="variables-feature-properties"></span>
<a href="#variables-feature-properties" name="variables-feature-properties" class="anchor glyphicon glyphicon-link"></a>Properties</h4>
<p><em>v1.6.0</em></p>
<pre><code class="lang-less"><span class="hljs-variable">@property:</span> color;

<span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">@{property}</span>: <span class="hljs-hexcolor">#0ee</span>;
  <span class="hljs-attribute">background-@{property}</span>: <span class="hljs-hexcolor">#999</span>;
}
</code></pre>
<p>Compiles to:</p>
<pre><code class="lang-css"><span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#0ee</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-hexcolor">#999</span>;
}
</code></pre>
<h3 id="variables-feature-variable-variables" class="docs-heading"><span class="anchor-target" id="variables-feature-variable-variables"></span>
<a href="#variables-feature-variable-variables" name="variables-feature-variable-variables" class="anchor glyphicon glyphicon-link"></a>Variable Variables</h3>
<p>In Less, you can define a variable&apos;s name using another variable.</p>
<pre><code class="lang-less"><span class="hljs-variable">@primary:</span>  green;
<span class="hljs-variable">@secondary:</span> blue;

<span class="hljs-class">.section</span> {
  <span class="hljs-variable">@color:</span> primary;

  <span class="hljs-class">.element</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">@@color</span>;
  }
}
</code></pre>
<p>Which compiles to:</p>
<pre><code class="lang-less"><span class="hljs-class">.section</span> <span class="hljs-class">.element</span> {
  <span class="hljs-attribute">color</span>: green;
}
</code></pre>
<p><span class="anchor-target" id="variables-feature-lazy-loading"></span>
<!-- ^ please keep old anchor to not break zillion outer links --></p>
<h3 id="variables-feature-lazy-evaluation" class="docs-heading"><span class="anchor-target" id="variables-feature-lazy-evaluation"></span>
<a href="#variables-feature-lazy-evaluation" name="variables-feature-lazy-evaluation" class="anchor glyphicon glyphicon-link"></a>Lazy Evaluation</h3>
<blockquote>
<p>Variables do not have to be declared before being used.</p>
</blockquote>
<p>Valid Less snippet:</p>
<pre><code class="lang-less"><span class="hljs-class">.lazy-eval</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-variable">@var</span>;
}

<span class="hljs-variable">@var:</span> <span class="hljs-variable">@a</span>;
<span class="hljs-variable">@a:</span> <span class="hljs-number">9%</span>;
</code></pre>
<p>this is valid Less too:</p>
<pre><code class="lang-less"><span class="hljs-class">.lazy-eval</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-variable">@var</span>;
  <span class="hljs-variable">@a:</span> <span class="hljs-number">9%</span>;
}

<span class="hljs-variable">@var:</span> <span class="hljs-variable">@a</span>;
<span class="hljs-variable">@a:</span> <span class="hljs-number">100%</span>;
</code></pre>
<p>both compile into:</p>
<pre><code class="lang-css"><span class="hljs-class">.lazy-eval</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">9%</span>;
}
</code></pre>
<p>When defining a variable twice, the last definition of the variable is used, searching from the current scope upwards. This is similar to css itself where the last property inside a definition is used to determine the value.</p>
<p>For instance:</p>
<pre><code class="lang-less"><span class="hljs-variable">@var:</span> <span class="hljs-number">0</span>;
<span class="hljs-class">.class</span> {
  <span class="hljs-variable">@var:</span> <span class="hljs-number">1</span>;
  <span class="hljs-class">.brass</span> {
    <span class="hljs-variable">@var:</span> <span class="hljs-number">2</span>;
    <span class="hljs-attribute">three</span>: <span class="hljs-variable">@var</span>;
    <span class="hljs-variable">@var:</span> <span class="hljs-number">3</span>;
  }
  <span class="hljs-attribute">one</span>: <span class="hljs-variable">@var</span>;
}
</code></pre>
<p>Compiles to:</p>
<pre><code class="lang-css"><span class="hljs-class">.class</span> {
  <span class="hljs-attribute">one</span>: <span class="hljs-number">1</span>;
}
<span class="hljs-class">.class</span> <span class="hljs-class">.brass</span> {
  <span class="hljs-attribute">three</span>: <span class="hljs-number">3</span>;
}
</code></pre>
<p>Essentially, each scope has a &quot;final&quot; value, similar to properties in the browser, like this example using custom properties:</p>
<pre><code class="lang-css"><span class="hljs-class">.header</span> {
  <span class="hljs-attribute">--color</span>: white;
  <span class="hljs-attribute">color</span>: <span class="hljs-function">var</span>(--color);  <span class="hljs-comment">// the color is black</span>
  <span class="hljs-attribute">--color</span>: black;
}
</code></pre>
<p>This means that, unlike other CSS pre-processing languages, Less variables behave very much like CSS&apos;s.</p>
<h3 id="variables-feature-properties-as-variables-new-" class="docs-heading"><span class="anchor-target" id="variables-feature-properties-as-variables-new-"></span>
<a href="#variables-feature-properties-as-variables-new-" name="variables-feature-properties-as-variables-new-" class="anchor glyphicon glyphicon-link"></a>Properties as Variables <strong>(NEW!)</strong></h3>
<p><em>v3.0.0</em></p>
<p>You can easily treat properties like variables using the <code>$prop</code> syntax. Sometimes this can
make your code a little lighter.</p>
<pre><code class="lang-less"><span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#efefef</span>;
  <span class="hljs-attribute">background-color</span>: $color;
}
</code></pre>
<p>Compiles to:</p>
<pre><code class="lang-css"><span class="hljs-class">.widget</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#efefef</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-hexcolor">#efefef</span>;
}
</code></pre>
<p>Note that, like variables, Less will choose the last property within the current/parent scope
as being the &quot;final&quot; value.</p>
<pre><code class="lang-less"><span class="hljs-class">.block</span> {
  <span class="hljs-attribute">color</span>: red; 
  <span class="hljs-class">.inner</span> {
    <span class="hljs-attribute">background-color</span>: $color; 
  }
  <span class="hljs-attribute">color</span>: blue;  
} 
</code></pre>
<p>Compiles to:</p>
<pre><code class="lang-css"><span class="hljs-class">.block</span> {
  <span class="hljs-attribute">color</span>: red; 
  <span class="hljs-attribute">color</span>: blue;  
} 
<span class="hljs-class">.block</span> <span class="hljs-class">.inner</span> {
  <span class="hljs-attribute">background-color</span>: blue; 
}
</code></pre>
<h3 id="variables-feature-default-variables" class="docs-heading"><span class="anchor-target" id="variables-feature-default-variables"></span>
<a href="#variables-feature-default-variables" name="variables-feature-default-variables" class="anchor glyphicon glyphicon-link"></a>Default Variables</h3>
<p>We sometimes get requests for default variables - an ability to set a variable only if it is not already set. This feature is not required because you can easily override a variable by putting the definition afterwards.</p>
<p>For instance:</p>
<pre><code class="lang-less"><span class="hljs-comment">// library</span>
<span class="hljs-variable">@base-color:</span> green;
<span class="hljs-variable">@dark-color:</span> <span class="hljs-function">darken</span>(<span class="hljs-variable">@base-color</span>, <span class="hljs-number">10%</span>);

<span class="hljs-comment">// use of library</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;library.less&quot;</span>;
<span class="hljs-variable">@base-color:</span> red;
</code></pre>
<p>This works fine because of <a href="#variables-feature-lazy-loading">Lazy Loading</a> - <code>@base-color</code> is overridden and <code>@dark-color</code> is a dark red.</p>


        <br>
      </div>
    

    

  </div>

  <!-- Parent Selectors -->
  <div class="docs-section">
    
    <h1 id="parent-selectors-feature" class="docs-heading"><span class="anchor-target" id="parent-selectors-feature"></span>
<a href="#parent-selectors-feature" name="parent-selectors-feature" class="anchor glyphicon glyphicon-link"></a>Parent Selectors</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/parent-selectors.md" data-content="parent-selectorsmd" target="_blank"></a>



<a id="parent-selectorsmd" href="https://github.com/less/less-docs/blob/master/content/features/parent-selectors.md" target="_blank">Edit the markdown source for &quot;parent-selectors&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- parent-selectors -->
         


        <blockquote>
<p>Referencing parent selectors with <code>&amp;</code></p>
</blockquote>
<p>The <code>&amp;</code> operator represents the parent selectors of a <a href="#features-overview-feature-nested-rules">nested rule</a> and is most commonly used when applying a modifying class or pseudo-class to an existing selector:</p>
<pre><code class="lang-less"><span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span>: blue;
  <span class="hljs-keyword">&amp;</span><span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: green;
  }
}
</code></pre>
<p>results in:</p>
<pre><code class="lang-css"><span class="hljs-tag">a</span> {
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-tag">a</span><span class="hljs-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span>: green;
}
</code></pre>
<p>Notice that without the <code>&amp;</code>, the above example would result in <code>a :hover</code> rule (a descendant selector that matches hovered elements inside of <code>&lt;a&gt;</code> tags) and this is not what we typically would want with the nested <code>:hover</code>.</p>
<p>The &quot;parent selectors&quot; operator has a variety of uses. Basically any time you need the selectors of the nested rules to be combined in other ways than the default. For example another typical use of the <code>&amp;</code> is to produce repetitive class names:</p>
<pre><code class="lang-less"><span class="hljs-class">.button</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-tag">-ok</span> {
    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;ok.png&quot;</span>);
  }
  <span class="hljs-keyword">&amp;</span><span class="hljs-tag">-cancel</span> {
    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;cancel.png&quot;</span>);
  }

  <span class="hljs-keyword">&amp;</span><span class="hljs-tag">-custom</span> {
    <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;custom.png&quot;</span>);
  }
}
</code></pre>
<p>output:</p>
<pre><code class="lang-css"><span class="hljs-class">.button-ok</span> {
  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;ok.png&quot;</span>);
}
<span class="hljs-class">.button-cancel</span> {
  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;cancel.png&quot;</span>);
}
<span class="hljs-class">.button-custom</span> {
  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&quot;custom.png&quot;</span>);
}
</code></pre>
<h3 id="parent-selectors-feature-multiple-" class="docs-heading"><span class="anchor-target" id="parent-selectors-feature-multiple-"></span>
<a href="#parent-selectors-feature-multiple-" name="parent-selectors-feature-multiple-" class="anchor glyphicon glyphicon-link"></a>Multiple <code>&amp;</code></h3>
<p><code>&amp;</code> may appear more than once within a selector. This makes it possible to repeatedly refer to a parent selector without repeating its name.</p>
<pre><code class="lang-less"><span class="hljs-class">.link</span> {
  <span class="hljs-keyword">&amp;</span> + <span class="hljs-keyword">&amp;</span> {
    <span class="hljs-attribute">color</span>: red;
  }

  <span class="hljs-keyword">&amp;</span> <span class="hljs-keyword">&amp;</span> {
    <span class="hljs-attribute">color</span>: green;
  }

  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">&amp;</span> {
    <span class="hljs-attribute">color</span>: blue;
  }

  <span class="hljs-keyword">&amp;</span>, <span class="hljs-keyword">&amp;</span><span class="hljs-tag">ish</span> {
    <span class="hljs-attribute">color</span>: cyan;
  }
}
</code></pre>
<p>will output:</p>
<pre><code class="lang-css"><span class="hljs-class">.link</span> + <span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-class">.link</span> <span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span>: green;
}
<span class="hljs-class">.link</span><span class="hljs-class">.link</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.link</span>, <span class="hljs-class">.linkish</span> {
  <span class="hljs-attribute">color</span>: cyan;
}
</code></pre>
<p>Note that <code>&amp;</code> represents all parent selectors (not just the nearest ancestor) so the following example:</p>
<pre><code class="lang-less"><span class="hljs-class">.grand</span> {
  <span class="hljs-class">.parent</span> {
    <span class="hljs-keyword">&amp;</span> &gt; <span class="hljs-keyword">&amp;</span> {
      <span class="hljs-attribute">color</span>: red;
    }

    <span class="hljs-keyword">&amp;</span> <span class="hljs-keyword">&amp;</span> {
      <span class="hljs-attribute">color</span>: green;
    }

    <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">&amp;</span> {
      <span class="hljs-attribute">color</span>: blue;
    }

    <span class="hljs-keyword">&amp;</span>, <span class="hljs-keyword">&amp;</span><span class="hljs-tag">ish</span> {
      <span class="hljs-attribute">color</span>: cyan;
    }
  }
}
</code></pre>
<p>results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> &gt; <span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> <span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> {
  <span class="hljs-attribute">color</span>: green;
}
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span><span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.grand</span> <span class="hljs-class">.parent</span>,
<span class="hljs-class">.grand</span> <span class="hljs-class">.parentish</span> {
  <span class="hljs-attribute">color</span>: cyan;
}
</code></pre>
<h3 id="parent-selectors-feature-changing-selector-order" class="docs-heading"><span class="anchor-target" id="parent-selectors-feature-changing-selector-order"></span>
<a href="#parent-selectors-feature-changing-selector-order" name="parent-selectors-feature-changing-selector-order" class="anchor glyphicon glyphicon-link"></a>Changing Selector Order</h3>
<p>It can be useful to prepend a selector to the inherited (parent) selectors.  This can be done by putting the <code>&amp;</code> after current selector.
For example, when using Modernizr, you might want to specify different rules based on supported features:</p>
<pre><code class="lang-less"><span class="hljs-class">.header</span> {
  <span class="hljs-class">.menu</span> {
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
    <span class="hljs-class">.no-borderradius</span> <span class="hljs-keyword">&amp;</span> {
      <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&apos;images/button-background.png&apos;</span>);
    }
  }
}
</code></pre>
<p>The selector <code>.no-borderradius &amp;</code> will prepend <code>.no-borderradius</code> to its parent <code>.header .menu</code> to form the<code>.no-borderradius .header .menu</code> on output:</p>
<pre><code class="lang-css"><span class="hljs-class">.header</span> <span class="hljs-class">.menu</span> {
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;
}
<span class="hljs-class">.no-borderradius</span> <span class="hljs-class">.header</span> <span class="hljs-class">.menu</span> {
  <span class="hljs-attribute">background-image</span>: url(<span class="hljs-string">&apos;images/button-background.png&apos;</span>);
}
</code></pre>
<h3 id="parent-selectors-feature-combinatorial-explosion" class="docs-heading"><span class="anchor-target" id="parent-selectors-feature-combinatorial-explosion"></span>
<a href="#parent-selectors-feature-combinatorial-explosion" name="parent-selectors-feature-combinatorial-explosion" class="anchor glyphicon glyphicon-link"></a>Combinatorial Explosion</h3>
<p><code>&amp;</code> can also be used to generate every possible permutation of selectors in a comma separated list:</p>
<pre><code class="lang-less"><span class="hljs-tag">p</span>, <span class="hljs-tag">a</span>, <span class="hljs-tag">ul</span>, <span class="hljs-tag">li</span> {
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">2px</span> dotted <span class="hljs-hexcolor">#366</span>;
  <span class="hljs-keyword">&amp;</span> + <span class="hljs-keyword">&amp;</span> {
    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>This expands to all possible (16) combinations of the specified elements:</p>
<pre><code class="lang-css"><span class="hljs-tag">p</span>,
<span class="hljs-tag">a</span>,
<span class="hljs-tag">ul</span>,
<span class="hljs-tag">li</span> {
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">2px</span> dotted <span class="hljs-hexcolor">#366</span>;
}
<span class="hljs-tag">p</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">p</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">a</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">ul</span> + <span class="hljs-tag">li</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">p</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">a</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">ul</span>,
<span class="hljs-tag">li</span> + <span class="hljs-tag">li</span> {
  <span class="hljs-attribute">border-top</span>: <span class="hljs-number">0</span>;
}
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- @import At-Rules -->
  <div class="docs-section">
    
    <h1 id="import-atrules-feature" class="docs-heading"><span class="anchor-target" id="import-atrules-feature"></span>
<a href="#import-atrules-feature" name="import-atrules-feature" class="anchor glyphicon glyphicon-link"></a>@import At-Rules</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/imports.md" data-content="importsmd" target="_blank"></a>



<a id="importsmd" href="https://github.com/less/less-docs/blob/master/content/features/imports.md" target="_blank">Edit the markdown source for &quot;imports&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- imports -->
         


        <blockquote>
<p>Import styles from other style sheets</p>
</blockquote>
<p>In standard CSS, <code>@import</code> at-rules must precede all other types of rules. But Less doesn&apos;t care where you put <code>@import</code> statements.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.foo</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#900</span>;
}
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;this-is-valid.less&quot;</span>;
</code></pre>
<h2 id="import-atrules-feature-file-extensions" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-file-extensions"></span>
<a href="#import-atrules-feature-file-extensions" name="import-atrules-feature-file-extensions" class="anchor glyphicon glyphicon-link"></a>File Extensions</h2>
<p><code>@import</code> statements may be treated differently by Less depending on the file extension:</p>
<ul>
<li>If the file has a <code>.css</code> extension it will be treated as CSS and the <code>@import</code> statement left as-is (see the <a href="#import-atrules-feature-inline">inline option</a> below).</li>
<li>If it has <em>any other extension</em> it will be treated as Less and imported.</li>
<li>If it does not have an extension, <code>.less</code> will be appended and it will be included as a imported Less file.</li>
</ul>
<p>Examples:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;foo&quot;</span>;      <span class="hljs-comment">// foo.less is imported</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;foo.less&quot;</span>; <span class="hljs-comment">// foo.less is imported</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;foo.php&quot;</span>;  <span class="hljs-comment">// foo.php imported as a Less file</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;foo.css&quot;</span>;  <span class="hljs-comment">// statement left in place, as-is</span>
</code></pre>
<p>The following options can be used to override this behavior.</p>
<h2 id="import-atrules-feature-import-options" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-import-options"></span>
<a href="#import-atrules-feature-import-options" name="import-atrules-feature-import-options" class="anchor glyphicon glyphicon-link"></a>Import Options</h2>
<blockquote>
<p>Less offers several extensions to the CSS <code>@import</code> CSS at-rule to provide more flexibility over what you can do with external files.</p>
</blockquote>
<p>Syntax: <code>@import (keyword) &quot;filename&quot;;</code></p>
<p>The following import options have been implemented:</p>
<ul>
<li><code>reference</code>: use a Less file but do not output it</li>
<li><code>inline</code>: include the source file in the output but do not process it</li>
<li><code>less</code>: treat the file as a Less file, no matter what the file extension</li>
<li><code>css</code>: treat the file as a CSS file, no matter what the file extension</li>
<li><code>once</code>: only include the file once (this is default behavior)</li>
<li><code>multiple</code>: include the file multiple times</li>
<li><code>optional</code>: continue compiling when file is not found</li>
</ul>
<blockquote>
<p>More than one keyword per <code>@import</code> is allowed, you will have to use commas to separate the keywords:</p>
</blockquote>
<p>Example: <code>@import (optional, reference) &quot;foo.less&quot;;</code></p>
<h3 id="import-atrules-feature-reference" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-reference"></span>
<a href="#import-atrules-feature-reference" name="import-atrules-feature-reference" class="anchor glyphicon glyphicon-link"></a>reference</h3>
<p>Use <code>@import (reference)</code> to import external files, but without adding the imported styles to the compiled output unless referenced.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.5.0</a></p>
<p>Example: <code>@import (reference) &quot;foo.less&quot;;</code></p>
<p>Imagine that <code>reference</code> marks every at-rule and selector with a <em>reference flag</em> in the imported file, imports as normal, but when the CSS is generated, &quot;reference&quot; selectors (as well as any media queries containing only reference selectors) are not output. <code>reference</code> styles will not show up in your generated CSS unless the reference styles are used as <a href="#mixins-feature">mixins</a> or <a href="#extend-feature">extended</a>.</p>
<p>Additionally, <strong><code>reference</code></strong> produces different results depending on which method was used (mixin or extend):</p>
<ul>
<li><strong><a href="#extend-feature">extend</a></strong>: When a selector is extended, only the new selector is marked as <em>not referenced</em>, and it is pulled in at the position of the reference <code>@import</code> statement.</li>
<li><strong><a href="#mixins-feature">mixins</a></strong>: When a <code>reference</code> style is used as an <a href="#mixins-feature">implicit mixin</a>, its rules are mixed-in, marked &quot;not reference&quot;, and appear in the referenced place as normal.</li>
</ul>
<h4 id="import-atrules-feature-reference-example" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-reference-example"></span>
<a href="#import-atrules-feature-reference-example" name="import-atrules-feature-reference-example" class="anchor glyphicon glyphicon-link"></a>reference example</h4>
<p>This allows you to pull in only specific, targeted styles from a library such as <a href="https://github.com/twbs/bootstrap">Bootstrap</a> by doing something like this:</p>
<pre><code class="lang-less"><span class="hljs-class">.navbar</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.navbar</span> <span class="hljs-keyword">all</span>) {}
</code></pre>
<p>And you will pull in only <code>.navbar</code> related styles from Bootstrap.</p>
<h3 id="import-atrules-feature-inline" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-inline"></span>
<a href="#import-atrules-feature-inline" name="import-atrules-feature-inline" class="anchor glyphicon glyphicon-link"></a>inline</h3>
<p>Use <code>@import (inline)</code> to include external files, but not process them.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.5.0</a></p>
<p>Example: <code>@import (inline) &quot;not-less-compatible.css&quot;;</code></p>
<p>You will use this when a CSS file may not be Less compatible; this is because although Less supports most known standards CSS, it does not support comments in some places and does not support all known CSS hacks without modifying the CSS.</p>
<p>So you can use this to include the file in the output so that all CSS will be in one file.</p>
<h3 id="import-atrules-feature-less" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-less"></span>
<a href="#import-atrules-feature-less" name="import-atrules-feature-less" class="anchor glyphicon glyphicon-link"></a>less</h3>
<p>Use <code>@import (less)</code> to treat imported files as Less, regardless of file extension.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.4.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@import</span> (less) <span class="hljs-string">&quot;foo.css&quot;</span>;
</code></pre>
<h3 id="import-atrules-feature-css" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-css"></span>
<a href="#import-atrules-feature-css" name="import-atrules-feature-css" class="anchor glyphicon glyphicon-link"></a>css</h3>
<p>Use <code>@import (css)</code> to treat imported files as regular CSS, regardless of file extension. This means the import statement will be left as it is.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.4.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@import</span> (css) <span class="hljs-string">&quot;foo.less&quot;</span>;
</code></pre>
<p>outputs</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;foo.less&quot;</span>;
</code></pre>
<h3 id="import-atrules-feature-once" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-once"></span>
<a href="#import-atrules-feature-once" name="import-atrules-feature-once" class="anchor glyphicon glyphicon-link"></a>once</h3>
<p>The default behavior of <code>@import</code> statements. It means the file is imported only once and subsequent import statements for that file will be ignored.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.4.0</a></p>
<p>This is the default behavior of <code>@import</code> statements.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@import</span> (once) <span class="hljs-string">&quot;foo.less&quot;</span>;
<span class="hljs-at_rule">@import</span> (once) <span class="hljs-string">&quot;foo.less&quot;</span>; <span class="hljs-comment">// this statement will be ignored</span>
</code></pre>
<h3 id="import-atrules-feature-multiple" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-multiple"></span>
<a href="#import-atrules-feature-multiple" name="import-atrules-feature-multiple" class="anchor glyphicon glyphicon-link"></a>multiple</h3>
<p>Use <code>@import (multiple)</code> to allow importing of multiple files with the same name. This is the opposite behavior to once.</p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.4.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-comment">// file: foo.less</span>
<span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span>: green;
}
<span class="hljs-comment">// file: main.less</span>
<span class="hljs-at_rule">@import</span> (multiple) <span class="hljs-string">&quot;foo.less&quot;</span>;
<span class="hljs-at_rule">@import</span> (multiple) <span class="hljs-string">&quot;foo.less&quot;</span>;
</code></pre>
<p>Outputs</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span>: green;
}
<span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span>: green;
}
</code></pre>
<h3 id="import-atrules-feature-optional" class="docs-heading"><span class="anchor-target" id="import-atrules-feature-optional"></span>
<a href="#import-atrules-feature-optional" name="import-atrules-feature-optional" class="anchor glyphicon glyphicon-link"></a>optional</h3>
<p>Use <code>@import (optional)</code> to allow importing of a file only when it exists. Without the <code>optional</code> keyword Less throws a FileError and stops compiling when importing a file that can not be found. </p>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v2.3.0</a></p>


        <br>
      </div>
    

    

  </div>

  <!-- Extend -->
  <div class="docs-section">
    
    <h1 id="extend-feature" class="docs-heading"><span class="anchor-target" id="extend-feature"></span>
<a href="#extend-feature" name="extend-feature" class="anchor glyphicon glyphicon-link"></a>Extend</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/extend.md" data-content="extendmd" target="_blank"></a>



<a id="extendmd" href="https://github.com/less/less-docs/blob/master/content/features/extend.md" target="_blank">Edit the markdown source for &quot;extend&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- extend -->
         


        <blockquote>
<p>Extend is a Less pseudo-class which merges the selector it is put on with ones that match what it references.</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.4.0</a></p>
<pre><code class="lang-less"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.inline</span>);
  <span class="hljs-attribute">background</span>: blue;
}
</code></pre>
<p>In the rule set above, the <code>:extend</code> selector will apply the &quot;extending selector&quot; (<code>nav ul</code>) onto the <code>.inline</code> class <em>wherever the <code>.inline</code> class appears</em>. The declaration block will be kept as-is, but without any reference to the extend (because extend isn&apos;t css).</p>
<p>So the following:</p>
<pre><code class="lang-less"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.inline</span>);
  <span class="hljs-attribute">background</span>: blue;
}
<span class="hljs-class">.inline</span> {
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  <span class="hljs-attribute">background</span>: blue;
}
<span class="hljs-class">.inline</span>,
<span class="hljs-tag">nav</span> <span class="hljs-tag">ul</span> {
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>Notice how the <code>nav ul:extend(.inline)</code> selector gets output as <code>nav ul</code> - the extend gets removed before output and the selector block left as-is. If no properties are put in that block then it gets removed from the output (but the extend still may affect other selectors).</p>
<h3 id="extend-feature-extend-syntax" class="docs-heading"><span class="anchor-target" id="extend-feature-extend-syntax"></span>
<a href="#extend-feature-extend-syntax" name="extend-feature-extend-syntax" class="anchor glyphicon glyphicon-link"></a>Extend Syntax</h3>
<p>The extend is either attached to a selector or placed into a ruleset. It looks like a pseudo-class with selector parameter optionally followed by the keyword <code>all</code>:</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.b</span>) {}

<span class="hljs-comment">// the above block does the same thing as the below block</span>
<span class="hljs-class">.a</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.b</span>);
}
</code></pre>
<pre><code class="lang-less"><span class="hljs-class">.c</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.d</span> <span class="hljs-keyword">all</span>) {
  <span class="hljs-comment">// extends all instances of &quot;.d&quot; e.g. &quot;.x.d&quot; or &quot;.d.x&quot;</span>
}
<span class="hljs-class">.c</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.d</span>) {
  <span class="hljs-comment">// extends only instances where the selector will be output as just &quot;.d&quot;</span>
}
</code></pre>
<p>It can contain one or more classes to extend, separated by commas.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.e</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.f</span>) {}
<span class="hljs-class">.e</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.g</span>) {}

<span class="hljs-comment">// the above and the below do the same thing</span>
<span class="hljs-class">.e</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.f</span>, <span class="hljs-class">.g</span>) {}
</code></pre>
<h3 id="extend-feature-extend-attached-to-selector" class="docs-heading"><span class="anchor-target" id="extend-feature-extend-attached-to-selector"></span>
<a href="#extend-feature-extend-attached-to-selector" name="extend-feature-extend-attached-to-selector" class="anchor glyphicon glyphicon-link"></a>Extend Attached to Selector</h3>
<p>Extend attached to a selector looks like an ordinary pseudo-class with selector as a parameter. A selector can contain multiple extend clauses, but all extends must be at the end of the selector.</p>
<ul>
<li>Extend after the selector: <code>pre:hover:extend(div pre)</code>.</li>
<li>Space between selector and extend is allowed: <code>pre:hover :extend(div pre)</code>.</li>
<li>Multiple extends are allowed: <code>pre:hover:extend(div pre):extend(.bucket tr)</code> - Note this is the same as <code>pre:hover:extend(div pre, .bucket tr)</code></li>
<li>This is NOT allowed: <code>pre:hover:extend(div pre).nth-child(odd)</code>. Extend must be last.</li>
</ul>
<p>If a ruleset contains multiple selectors, any of them can have the extend keyword. Multiple selectors with extend in one ruleset:</p>
<pre><code class="lang-less"><span class="hljs-class">.big-division</span>,
<span class="hljs-class">.big-bag</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.bag</span>),
<span class="hljs-class">.big-bucket</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.bucket</span>) {
  <span class="hljs-comment">// body</span>
}
</code></pre>
<h3 id="extend-feature-extend-inside-ruleset" class="docs-heading"><span class="anchor-target" id="extend-feature-extend-inside-ruleset"></span>
<a href="#extend-feature-extend-inside-ruleset" name="extend-feature-extend-inside-ruleset" class="anchor glyphicon glyphicon-link"></a>Extend Inside Ruleset</h3>
<p>Extend can be placed into a ruleset&apos;s body using <code>&amp;:extend(selector)</code> syntax. Placing extend into a body is a shortcut for placing it into every single selector of that ruleset.</p>
<p>Extend inside a body:</p>
<pre><code class="lang-less"><span class="hljs-tag">pre</span><span class="hljs-pseudo">:hover</span>,
<span class="hljs-class">.some-class</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">div</span> <span class="hljs-tag">pre</span>);
}
</code></pre>
<p>is exactly the same as adding an extend after each selector:</p>
<pre><code class="lang-less"><span class="hljs-tag">pre</span><span class="hljs-pseudo">:hover</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">div</span> <span class="hljs-tag">pre</span>),
<span class="hljs-class">.some-class</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">div</span> <span class="hljs-tag">pre</span>) {}
</code></pre>
<h3 id="extend-feature-extending-nested-selectors" class="docs-heading"><span class="anchor-target" id="extend-feature-extending-nested-selectors"></span>
<a href="#extend-feature-extending-nested-selectors" name="extend-feature-extending-nested-selectors" class="anchor glyphicon glyphicon-link"></a>Extending Nested Selectors</h3>
<p>Extend is able to match nested selectors. Following less:</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-tag">tr</span> { <span class="hljs-comment">// nested ruleset with target selector</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
<span class="hljs-class">.some-class</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.bucket</span> <span class="hljs-tag">tr</span>) {} <span class="hljs-comment">// nested ruleset is recognized</span>
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.bucket</span> <span class="hljs-tag">tr</span>,
<span class="hljs-class">.some-class</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p>Essentially the extend looks at the compiled css, not the original less.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-tag">tr</span> <span class="hljs-keyword">&amp;</span> { <span class="hljs-comment">// nested ruleset with target selector</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
<span class="hljs-class">.some-class</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">tr</span> <span class="hljs-class">.bucket</span>) {} <span class="hljs-comment">// nested ruleset is recognized</span>
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-tag">tr</span> <span class="hljs-class">.bucket</span>,
<span class="hljs-class">.some-class</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<h3 id="extend-feature-exact-matching-with-extend" class="docs-heading"><span class="anchor-target" id="extend-feature-exact-matching-with-extend"></span>
<a href="#extend-feature-exact-matching-with-extend" name="extend-feature-exact-matching-with-extend" class="anchor glyphicon glyphicon-link"></a>Exact Matching with Extend</h3>
<p>Extend by default looks for exact match between selectors. It does matter whether selector uses leading star or not. It does not matter that two nth-expressions have the same meaning, they need to have to same form in order to be matched. The only exception are quotes in attribute selector, less knows they have the same meaning and matches them.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-class">.class</span>,
<span class="hljs-class">.class</span><span class="hljs-class">.a</span>,
<span class="hljs-class">.class</span> &gt; <span class="hljs-class">.a</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.test</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.class</span>) {} <span class="hljs-comment">// this will NOT match the any selectors above</span>
</code></pre>
<p>Leading star does matter. Selectors <code>*.class</code> and <code>.class</code> are equivalent, but extend will not match them:</p>
<pre><code class="lang-less">*<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.noStar</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.class</span>) {} <span class="hljs-comment">// this will NOT match the *.class selector</span>
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css">*<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p>Order of pseudo-classes does matter. Selectors <code>link:hover:visited</code> and <code>link:visited:hover</code> match the same set of elements, but extend treats them as different:</p>
<pre><code class="lang-less"><span class="hljs-tag">link</span><span class="hljs-pseudo">:hover</span><span class="hljs-pseudo">:visited</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.selector</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">link</span><span class="hljs-pseudo">:visited</span><span class="hljs-pseudo">:hover</span>) {}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-tag">link</span><span class="hljs-pseudo">:hover</span><span class="hljs-pseudo">:visited</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<h3 id="extend-feature-nth-expression" class="docs-heading"><span class="anchor-target" id="extend-feature-nth-expression"></span>
<a href="#extend-feature-nth-expression" name="extend-feature-nth-expression" class="anchor glyphicon glyphicon-link"></a>nth Expression</h3>
<p>Nth expression form does matter. Nth-expressions <code>1n+3</code> and <code>n+3</code> are equivalent, but extend will not match them:</p>
<pre><code class="lang-less"><span class="hljs-pseudo">:nth-child</span>(<span class="hljs-number">1</span>n+<span class="hljs-number">3</span>) {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.child</span><span class="hljs-keyword">:extend</span>(<span class="hljs-pseudo">:nth-child</span>(n+<span class="hljs-number">3</span>)) {}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-pseudo">:nth-child</span>(<span class="hljs-number">1</span>n+<span class="hljs-number">3</span>) {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p>Quote type in attribute selector does not matter. All of the following are equivalent.</p>
<pre><code class="lang-less"><span class="hljs-attr_selector">[title=identifier]</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-attr_selector">[title=&apos;identifier&apos;]</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-attr_selector">[title=&quot;identifier&quot;]</span> {
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-class">.noQuote</span><span class="hljs-keyword">:extend</span>(<span class="hljs-attr_selector">[title=identifier]</span>) {}
<span class="hljs-class">.singleQuote</span><span class="hljs-keyword">:extend</span>(<span class="hljs-attr_selector">[title=&apos;identifier&apos;]</span>) {}
<span class="hljs-class">.doubleQuote</span><span class="hljs-keyword">:extend</span>(<span class="hljs-attr_selector">[title=&quot;identifier&quot;]</span>) {}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-attr_selector">[title=identifier]</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> {
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-attr_selector">[title=&apos;identifier&apos;]</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> {
  <span class="hljs-attribute">color</span>: blue;
}

<span class="hljs-attr_selector">[title=&quot;identifier&quot;]</span>,
<span class="hljs-class">.noQuote</span>,
<span class="hljs-class">.singleQuote</span>,
<span class="hljs-class">.doubleQuote</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<h3 id="extend-feature-extend-all" class="docs-heading"><span class="anchor-target" id="extend-feature-extend-all"></span>
<a href="#extend-feature-extend-all" name="extend-feature-extend-all" class="anchor glyphicon glyphicon-link"></a>Extend &quot;all&quot;</h3>
<p>When you specify the all keyword last in an extend argument it tells Less to match that selector as part of another selector. The selector will be copied and the matched part of the selector only will then be replaced with the extend, making a new selector.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.test</span>,
<span class="hljs-class">.test</span><span class="hljs-class">.c</span> {
  <span class="hljs-attribute">color</span>: orange;
}
<span class="hljs-class">.test</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">color</span>: green;
  }
}

<span class="hljs-class">.replacement</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.test</span> <span class="hljs-keyword">all</span>) {}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.test</span>,
<span class="hljs-class">.test</span><span class="hljs-class">.c</span>,
<span class="hljs-class">.a</span><span class="hljs-class">.b</span><span class="hljs-class">.replacement</span>,
<span class="hljs-class">.replacement</span><span class="hljs-class">.c</span> {
  <span class="hljs-attribute">color</span>: orange;
}
<span class="hljs-class">.test</span><span class="hljs-pseudo">:hover</span>,
<span class="hljs-class">.replacement</span><span class="hljs-pseudo">:hover</span> {
  <span class="hljs-attribute">color</span>: green;
}
</code></pre>
<p><em>You can think of this mode of operation as essentially doing a non-destructive search and replace.</em></p>
<h3 id="extend-feature-selector-interpolation-with-extend" class="docs-heading"><span class="anchor-target" id="extend-feature-selector-interpolation-with-extend"></span>
<a href="#extend-feature-selector-interpolation-with-extend" name="extend-feature-selector-interpolation-with-extend" class="anchor glyphicon glyphicon-link"></a>Selector Interpolation with Extend</h3>
<blockquote>
<p>Extend is <strong>not</strong> able to match selectors with variables. If selector contains variable, extend will ignore it.</p>
</blockquote>
<p>However, extend can be attached to interpolated selector.</p>
<p>Selector with variable will not be matched:</p>
<pre><code class="lang-less"><span class="hljs-variable">@variable:</span> .bucket;
<span class="hljs-variable">@{variable}</span> { <span class="hljs-comment">// interpolated selector</span>
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.some-class</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.bucket</span>) {} <span class="hljs-comment">// does nothing, no match is found</span>
</code></pre>
<p>and extend with variable in target selector matches nothing:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-class">.some-class</span><span class="hljs-keyword">:extend</span>(<span class="hljs-variable">@{variable}</span>) {} <span class="hljs-comment">// interpolated selector matches nothing</span>
<span class="hljs-variable">@variable:</span> .bucket;
</code></pre>
<p>Both of the above examples compile into:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p>However, <code>:extend</code> attached to an interpolated selector works:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span> {
  <span class="hljs-attribute">color</span>: blue;
}
<span class="hljs-variable">@{variable}</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.bucket</span>) {}
<span class="hljs-variable">@variable:</span> .selector;
</code></pre>
<p>compiles to:</p>
<pre><code class="lang-less"><span class="hljs-class">.bucket</span>, <span class="hljs-class">.selector</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<h3 id="extend-feature-scoping-extend-inside-media" class="docs-heading"><span class="anchor-target" id="extend-feature-scoping-extend-inside-media"></span>
<a href="#extend-feature-scoping-extend-inside-media" name="extend-feature-scoping-extend-inside-media" class="anchor glyphicon glyphicon-link"></a>Scoping / Extend Inside @media</h3>
<p>Currently, an <code>:extend</code> inside a <code>@media</code> declaration will only match selectors inside the same media declaration:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@media</span> print {
  <span class="hljs-class">.screenClass</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.selector</span>) {} <span class="hljs-comment">// extend inside media</span>
  <span class="hljs-class">.selector</span> { <span class="hljs-comment">// this will be matched - it is in the same media</span>
    <span class="hljs-attribute">color</span>: black;
  }
}
<span class="hljs-class">.selector</span> { <span class="hljs-comment">// ruleset on top of style sheet - extend ignores it</span>
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-at_rule">@media</span> screen {
  <span class="hljs-class">.selector</span> {  <span class="hljs-comment">// ruleset inside another media - extend ignores it</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@media</span> print {
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.screenClass</span> { <span class="hljs-comment">/*  ruleset inside the same media was extended */</span>
    <span class="hljs-attribute">color</span>: black;
  }
}
<span class="hljs-class">.selector</span> { <span class="hljs-comment">/* ruleset on top of style sheet was ignored */</span>
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-at_rule">@media</span> screen {
  <span class="hljs-class">.selector</span> { <span class="hljs-comment">/* ruleset inside another media was ignored */</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
</code></pre>
<p>Note: extending does not match selectors inside a nested <code>@media</code> declaration:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@media</span> screen {
  <span class="hljs-class">.screenClass</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.selector</span>) {} <span class="hljs-comment">// extend inside media</span>
  <span class="hljs-at_rule">@media</span> (min-width: <span class="hljs-number">1023px</span>) {
    <span class="hljs-class">.selector</span> {  <span class="hljs-comment">// ruleset inside nested media - extend ignores it</span>
      <span class="hljs-attribute">color</span>: blue;
    }
  }
}
</code></pre>
<p>This compiles into:</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@media</span> screen and (min-width: <span class="hljs-number">1023px</span>) {
  <span class="hljs-class">.selector</span> { <span class="hljs-comment">/* ruleset inside another nested media was ignored */</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
</code></pre>
<p>Top level extend matches everything including selectors inside nested media:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@media</span> screen {
  <span class="hljs-class">.selector</span> {  <span class="hljs-comment">/* ruleset inside nested media - top level extend works */</span>
    <span class="hljs-attribute">color</span>: blue;
  }
  <span class="hljs-at_rule">@media</span> (min-width: <span class="hljs-number">1023px</span>) {
    <span class="hljs-class">.selector</span> {  <span class="hljs-comment">/* ruleset inside nested media - top level extend works */</span>
      <span class="hljs-attribute">color</span>: blue;
    }
  }
}

<span class="hljs-class">.topLevel</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.selector</span>) {} <span class="hljs-comment">/* top level extend matches everything */</span>
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@media</span> screen {
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.topLevel</span> { <span class="hljs-comment">/* ruleset inside media was extended */</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
<span class="hljs-at_rule">@media</span> screen and (min-width: <span class="hljs-number">1023px</span>) {
  <span class="hljs-class">.selector</span>,
  <span class="hljs-class">.topLevel</span> { <span class="hljs-comment">/* ruleset inside nested media was extended */</span>
    <span class="hljs-attribute">color</span>: blue;
  }
}
</code></pre>
<h3 id="extend-feature-duplication-detection" class="docs-heading"><span class="anchor-target" id="extend-feature-duplication-detection"></span>
<a href="#extend-feature-duplication-detection" name="extend-feature-duplication-detection" class="anchor glyphicon glyphicon-link"></a>Duplication Detection</h3>
<p>Currently there is no duplication detection.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.alert-info</span>,
<span class="hljs-class">.widget</span> {
  <span class="hljs-comment">/* declarations */</span>
}

<span class="hljs-class">.alert</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.alert-info</span>, <span class="hljs-class">.widget</span>) {}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.alert-info</span>,
<span class="hljs-class">.widget</span>,
<span class="hljs-class">.alert</span>,
<span class="hljs-class">.alert</span> {
  <span class="hljs-comment">/* declarations */</span>
}
</code></pre>
<h3 id="extend-feature-use-cases-for-extend" class="docs-heading"><span class="anchor-target" id="extend-feature-use-cases-for-extend"></span>
<a href="#extend-feature-use-cases-for-extend" name="extend-feature-use-cases-for-extend" class="anchor glyphicon glyphicon-link"></a>Use Cases for Extend</h3>
<h4 id="extend-feature-classic-use-case" class="docs-heading"><span class="anchor-target" id="extend-feature-classic-use-case"></span>
<a href="#extend-feature-classic-use-case" name="extend-feature-classic-use-case" class="anchor glyphicon glyphicon-link"></a>Classic Use Case</h4>
<p>The classic use case is to avoid adding a base class. For example, if you have</p>
<pre><code class="lang-css"><span class="hljs-class">.animal</span> {
  <span class="hljs-attribute">background-color</span>: black;
  <span class="hljs-attribute">color</span>: white;
}
</code></pre>
<p>and you want to have a subtype of animal which overrides the background color then you have two options, firstly change your HTML</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;animal bear&quot;</span>&gt;</span>Bear<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<pre><code class="lang-css"><span class="hljs-class">.animal</span> {
  <span class="hljs-attribute">background-color</span>: black;
  <span class="hljs-attribute">color</span>: white;
}
<span class="hljs-class">.bear</span> {
  <span class="hljs-attribute">background-color</span>: brown;
}
</code></pre>
<p>or have simplified html and use extend in your less. e.g.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bear&quot;</span>&gt;</span>Bear<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<pre><code class="lang-less"><span class="hljs-class">.animal</span> {
  <span class="hljs-attribute">background-color</span>: black;
  <span class="hljs-attribute">color</span>: white;
}
<span class="hljs-class">.bear</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.animal</span>);
  <span class="hljs-attribute">background-color</span>: brown;
}
</code></pre>
<h4 id="extend-feature-reducing-css-size" class="docs-heading"><span class="anchor-target" id="extend-feature-reducing-css-size"></span>
<a href="#extend-feature-reducing-css-size" name="extend-feature-reducing-css-size" class="anchor glyphicon glyphicon-link"></a>Reducing CSS Size</h4>
<p>Mixins copy all of the properties into a selector, which can lead to unnecessary duplication. Therefore you can use extends instead of mixins to move the selector up to the properties you wish to use, which leads to less CSS being generated.</p>
<p>Example - with mixin:</p>
<pre><code class="lang-less"><span class="hljs-class">.my-inline-block</span>() {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;
}
<span class="hljs-class">.thing1</span> {
  <span class="hljs-class">.my-inline-block</span>;
}
<span class="hljs-class">.thing2</span> {
  <span class="hljs-class">.my-inline-block</span>;
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.thing1</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;
}
<span class="hljs-class">.thing2</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;
}
</code></pre>
<p>Example (with extends):</p>
<pre><code class="lang-less"><span class="hljs-class">.my-inline-block</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;
}
<span class="hljs-class">.thing1</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.my-inline-block</span>);
}
<span class="hljs-class">.thing2</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-class">.my-inline-block</span>);
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.my-inline-block</span>,
<span class="hljs-class">.thing1</span>,
<span class="hljs-class">.thing2</span> {
  <span class="hljs-attribute">display</span>: inline-block;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="extend-feature-combining-styles-a-more-advanced-mixin" class="docs-heading"><span class="anchor-target" id="extend-feature-combining-styles-a-more-advanced-mixin"></span>
<a href="#extend-feature-combining-styles-a-more-advanced-mixin" name="extend-feature-combining-styles-a-more-advanced-mixin" class="anchor glyphicon glyphicon-link"></a>Combining Styles / A More Advanced Mixin</h4>
<p>Another use-case is as an alternative for a mixin - because mixins can only be used with simple selectors, if you have two different blocks of html, but need to apply the same styles to both you can use extends to relate two areas.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-tag">li</span><span class="hljs-class">.list</span> &gt; <span class="hljs-tag">a</span> {
  <span class="hljs-comment">// list styles</span>
}
<span class="hljs-tag">button</span><span class="hljs-class">.list-style</span> {
  <span class="hljs-keyword">&amp;</span><span class="hljs-keyword">:extend</span>(<span class="hljs-tag">li</span><span class="hljs-class">.list</span> &gt; <span class="hljs-tag">a</span>); <span class="hljs-comment">// use the same list styles</span>
}
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- Merge properties -->
  <div class="docs-section">
    
    <h1 id="merge-feature" class="docs-heading"><span class="anchor-target" id="merge-feature"></span>
<a href="#merge-feature" name="merge-feature" class="anchor glyphicon glyphicon-link"></a>Merge properties</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/merge.md" data-content="mergemd" target="_blank"></a>



<a id="mergemd" href="https://github.com/less/less-docs/blob/master/content/features/merge.md" target="_blank">Edit the markdown source for &quot;merge&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- merge -->
         


        <blockquote>
<p>Combine properties</p>
</blockquote>
<p>The <code>merge</code> feature allows for aggregating values from multiple properties into a comma or space separated list under a single property. <code>merge</code> is useful for properties such as background and transform.</p>
<h3 id="merge-feature-comma" class="docs-heading"><span class="anchor-target" id="merge-feature-comma"></span>
<a href="#merge-feature-comma" name="merge-feature-comma" class="anchor glyphicon glyphicon-link"></a>Comma</h3>
<blockquote>
<p>Append property value with comma</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.5.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-attribute">box-shadow</span>+: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-hexcolor">#555</span>;
}
<span class="hljs-class">.myclass</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">box-shadow</span>+: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> black;
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.myclass</span> {
  <span class="hljs-attribute">box-shadow</span>: inset <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-hexcolor">#555</span>, <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span> black;
}
</code></pre>
<h3 id="merge-feature-space" class="docs-heading"><span class="anchor-target" id="merge-feature-space"></span>
<a href="#merge-feature-space" name="merge-feature-space" class="anchor glyphicon glyphicon-link"></a>Space</h3>
<blockquote>
<p>Append property value with space</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.7.0</a></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-attribute">transform</span>+_: <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>);
}
<span class="hljs-class">.myclass</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">transform</span>+_: <span class="hljs-function">rotate</span>(<span class="hljs-number">15deg</span>);
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.myclass</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-function">scale</span>(<span class="hljs-number">2</span>) <span class="hljs-function">rotate</span>(<span class="hljs-number">15deg</span>);
}
</code></pre>
<p>To avoid any unintentional joins, <code>merge</code> requires an explicit <code>+</code> or <code>+_</code> flag on each join pending declaration.</p>


        <br>
      </div>
    

    

  </div>

  <!-- Mixins -->
  <div class="docs-section">
    
    <h1 id="mixins-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature"></span>
<a href="#mixins-feature" name="mixins-feature" class="anchor glyphicon glyphicon-link"></a>Mixins</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixins.md" data-content="mixinsmd" target="_blank"></a>



<a id="mixinsmd" href="https://github.com/less/less-docs/blob/master/content/features/mixins.md" target="_blank">Edit the markdown source for &quot;mixins&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- mixins -->
         


        <blockquote>
<p>&quot;mix-in&quot; properties from existing styles</p>
</blockquote>
<p>You can mix-in class selectors and id selectors, e.g.</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span>, <span class="hljs-id">#b</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-class">.mixin-class</span> {
  <span class="hljs-class">.a</span>();
}
<span class="hljs-class">.mixin-id</span> {
  <span class="hljs-id">#b</span>();
}
</code></pre>
<p>which results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.a</span>, <span class="hljs-id">#b</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-class">.mixin-class</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-class">.mixin-id</span> {
  <span class="hljs-attribute">color</span>: red;
}
</code></pre>
<p>Historically, the parentheses in a mixin call are optional, but optional parentheses are deprecated and will be required in a future release.</p>
<pre><code class="lang-less"><span class="hljs-class">.a</span>(); 
<span class="hljs-class">.a</span>;    <span class="hljs-comment">// currently works, but deprecated; don&apos;t use</span>
<span class="hljs-class">.a</span> (); <span class="hljs-comment">// white-space before parentheses is also deprecated</span>
</code></pre>
<h2 id="mixins-feature-mixins-with-parentheses" class="docs-heading"><span class="anchor-target" id="mixins-feature-mixins-with-parentheses"></span>
<a href="#mixins-feature-mixins-with-parentheses" name="mixins-feature-mixins-with-parentheses" class="anchor glyphicon glyphicon-link"></a>Mixins With Parentheses</h2>
<p>If you want to create a mixin but you do not want that mixin to be in your CSS output, put parentheses after the mixin definition.</p>
<pre><code class="lang-less"><span class="hljs-class">.my-mixin</span> {
  <span class="hljs-attribute">color</span>: black;
}
<span class="hljs-class">.my-other-mixin</span>() {
  <span class="hljs-attribute">background</span>: white;
}
<span class="hljs-class">.class</span> {
  <span class="hljs-class">.my-mixin</span>();
  <span class="hljs-class">.my-other-mixin</span>();
}
</code></pre>
<p>outputs</p>
<pre><code class="lang-css"><span class="hljs-class">.my-mixin</span> {
  <span class="hljs-attribute">color</span>: black;
}
<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">color</span>: black;
  <span class="hljs-attribute">background</span>: white;
}
</code></pre>
<h2 id="mixins-feature-selectors-in-mixins" class="docs-heading"><span class="anchor-target" id="mixins-feature-selectors-in-mixins"></span>
<a href="#mixins-feature-selectors-in-mixins" name="mixins-feature-selectors-in-mixins" class="anchor glyphicon glyphicon-link"></a>Selectors in Mixins</h2>
<p>Mixins can contain more than just properties, they can contain selectors too.</p>
<p>For example:</p>
<pre><code class="lang-less"><span class="hljs-class">.my-hover-mixin</span>() {
  <span class="hljs-keyword">&amp;</span><span class="hljs-pseudo">:hover</span> {
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
  }
}
<span class="hljs-tag">button</span> {
  <span class="hljs-class">.my-hover-mixin</span>();
}
</code></pre>
<p>Outputs</p>
<pre><code class="lang-css"><span class="hljs-tag">button</span><span class="hljs-pseudo">:hover</span> {
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
}
</code></pre>
<h2 id="mixins-feature-namespaces" class="docs-heading"><span class="anchor-target" id="mixins-feature-namespaces"></span>
<a href="#mixins-feature-namespaces" name="mixins-feature-namespaces" class="anchor glyphicon glyphicon-link"></a>Namespaces</h2>
<p>If you want to mixin properties inside a more complicated selector, you can stack up multiple ids or classes.</p>
<pre><code class="lang-less"><span class="hljs-id">#outer</span>() {
  <span class="hljs-class">.inner</span> {
    <span class="hljs-attribute">color</span>: red;
  }
}

<span class="hljs-class">.c</span> {
  <span class="hljs-id">#outer</span><span class="hljs-class">.inner</span>();
}
</code></pre>
<p>Note: legacy Less syntax allows <code>&gt;</code> and whitespace between namespaces and mixins. This syntax is deprecated and may be removed. Currently, these do the same thing.</p>
<pre><code class="lang-less"><span class="hljs-id">#outer</span> &gt; <span class="hljs-class">.inner</span>(); <span class="hljs-comment">// deprecated</span>
<span class="hljs-id">#outer</span> <span class="hljs-class">.inner</span>();   <span class="hljs-comment">// deprecated</span>
<span class="hljs-id">#outer</span><span class="hljs-class">.inner</span>();    <span class="hljs-comment">// preferred</span>
</code></pre>
<p>Namespacing your mixins like this reduces conflicts with other library mixins or user mixins, but can also be a way to &quot;organize&quot; groups of mixins.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-id">#my-library</span> {
  <span class="hljs-class">.my-mixin</span>() {
    <span class="hljs-attribute">color</span>: black;
  }
}
<span class="hljs-comment">// which can be used like this</span>
<span class="hljs-class">.class</span> {
  <span class="hljs-id">#my-library</span><span class="hljs-class">.my-mixin</span>();
}
</code></pre>
<h2 id="mixins-feature-guarded-namespaces" class="docs-heading"><span class="anchor-target" id="mixins-feature-guarded-namespaces"></span>
<a href="#mixins-feature-guarded-namespaces" name="mixins-feature-guarded-namespaces" class="anchor glyphicon glyphicon-link"></a>Guarded Namespaces</h2>
<p>If a namespace has a guard, mixins defined by it are used only if the guard condition returns true. A namespace guard is evaluated exactly the same as a guard on a mixin, so the following two mixins work the same way:</p>
<pre><code class="lang-less"><span class="hljs-id">#namespace</span> <span class="hljs-keyword">when</span> (<span class="hljs-variable">@mode</span> = huge) {
  <span class="hljs-class">.mixin</span>() { <span class="hljs-comment">/* */</span> }
}

<span class="hljs-id">#namespace</span> {
  <span class="hljs-class">.mixin</span>() <span class="hljs-keyword">when</span> (<span class="hljs-variable">@mode</span> = huge) { <span class="hljs-comment">/* */</span> }
}
</code></pre>
<p>The <code>default</code> function is assumed to have the same value for all nested namespaces and mixin. The following mixin is never evaluated; one of its guards is guaranteed to be false:</p>
<pre><code class="lang-less"><span class="hljs-id">#sp_1</span> <span class="hljs-keyword">when</span> (<span class="hljs-function">default</span>()) {
  <span class="hljs-id">#sp_2</span> <span class="hljs-keyword">when</span> (<span class="hljs-function">default</span>()) {
    <span class="hljs-class">.mixin</span>() <span class="hljs-keyword">when</span> <span class="hljs-keyword">not</span>(<span class="hljs-function">default</span>()) { <span class="hljs-comment">/* */</span> }
  }
}
</code></pre>
<h2 id="mixins-feature-the-important-keyword" class="docs-heading"><span class="anchor-target" id="mixins-feature-the-important-keyword"></span>
<a href="#mixins-feature-the-important-keyword" name="mixins-feature-the-important-keyword" class="anchor glyphicon glyphicon-link"></a>The <code>!important</code> keyword</h2>
<p>Use the <code>!important</code> keyword after mixin call to mark all properties inherited by it as <code>!important</code>:</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.foo</span> (<span class="hljs-variable">@bg</span>: <span class="hljs-hexcolor">#f5f5f5</span>, <span class="hljs-variable">@color</span>: <span class="hljs-hexcolor">#900</span>) {
  <span class="hljs-attribute">background</span>: <span class="hljs-variable">@bg</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;
}
<span class="hljs-class">.unimportant</span> {
  <span class="hljs-class">.foo</span>();
}
<span class="hljs-class">.important</span> {
  <span class="hljs-class">.foo</span>() !important;
}
</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.unimportant</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#f5f5f5</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#900</span>;
}
<span class="hljs-class">.important</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-hexcolor">#f5f5f5</span> !important;
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#900</span> !important;
}
</code></pre>


        <br>
      </div>
    

    

      <!-- Parametric Mixins -->
      <h2 id="mixins-feature-mixins-parametric-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature-mixins-parametric-feature"></span>
<a href="#mixins-feature-mixins-parametric-feature" name="mixins-feature-mixins-parametric-feature" class="anchor glyphicon glyphicon-link"></a>Parametric Mixins</h2>
      
      
        <div class="section-content">
          
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixins-parametric.md" data-content="mixins-parametricmd" target="_blank"></a>



<a id="mixins-parametricmd" href="https://github.com/less/less-docs/blob/master/content/features/mixins-parametric.md" target="_blank">Edit the markdown source for &quot;mixins-parametric&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


          <!-- mixins-parametric -->
           


          <blockquote>
<p>How to pass arguments to mixins</p>
</blockquote>
<p>Mixins can also take arguments, which are variables passed to the block of selectors when it is mixed in.</p>
<p>For example:</p>
<pre><code class="lang-less"><span class="hljs-class">.border-radius</span>(<span class="hljs-variable">@radius</span>) {
  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-variable">@radius</span>;
     <span class="hljs-attribute">-moz-border-radius</span>: <span class="hljs-variable">@radius</span>;
          <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;
}
</code></pre>
<p>And here&apos;s how we can mix it into various rulesets:</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> {
  <span class="hljs-class">.border-radius</span>(<span class="hljs-number">4px</span>);
}
<span class="hljs-class">.button</span> {
  <span class="hljs-class">.border-radius</span>(<span class="hljs-number">6px</span>);
}
</code></pre>
<p>Parametric mixins can also have default values for their parameters:</p>
<pre><code class="lang-less"><span class="hljs-class">.border-radius</span>(<span class="hljs-variable">@radius</span>: <span class="hljs-number">5px</span>) {
  <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-variable">@radius</span>;
     <span class="hljs-attribute">-moz-border-radius</span>: <span class="hljs-variable">@radius</span>;
          <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;
}
</code></pre>
<p>We can invoke it like this now:</p>
<pre><code class="lang-less"><span class="hljs-id">#header</span> {
  <span class="hljs-class">.border-radius</span>();
}
</code></pre>
<p>And it will include a 5px border-radius.</p>
<p>You can also use parametric mixins which don&apos;t take parameters. This is useful if you want to hide the ruleset from the CSS output, but want to include its properties in other rulesets:</p>
<pre><code class="lang-less"><span class="hljs-class">.wrap</span>() {
  <span class="hljs-attribute">text-wrap</span>: wrap;
  <span class="hljs-attribute">white-space</span>: -moz-pre-wrap;
  <span class="hljs-attribute">white-space</span>: pre-wrap;
  <span class="hljs-attribute">word-wrap</span>: break-word;
}

<span class="hljs-tag">pre</span> { <span class="hljs-class">.wrap</span>() }
</code></pre>
<p>Which would output:</p>
<pre><code class="lang-css"><span class="hljs-tag">pre</span> {
  <span class="hljs-attribute">text-wrap</span>: wrap;
  <span class="hljs-attribute">white-space</span>: -moz-pre-wrap;
  <span class="hljs-attribute">white-space</span>: pre-wrap;
  <span class="hljs-attribute">word-wrap</span>: break-word;
}
</code></pre>
<h4 id="mixins-feature-parameter-separators" class="docs-heading"><span class="anchor-target" id="mixins-feature-parameter-separators"></span>
<a href="#mixins-feature-parameter-separators" name="mixins-feature-parameter-separators" class="anchor glyphicon glyphicon-link"></a>Parameter separators</h4>
<p>Parameters are currently either <em>semicolon</em> or <em>comma</em> separated.</p>
<p>Originally, parameters were only separated by commas, but the semi-colon was later added to support passing comma-separated list values to single arguments.</p>
<p>Note: As of Less 4.0, you can wrap a list value using a paren escape [<code>~()</code>], e.g. <code>.name(@param1: ~(red, blue))</code>. This is similar to the quote escape syntax: <code>~&quot;quote&quot;</code>. This may make semi-colon separators un-necessary in your code-base.</p>
<p>Examples:</p>
<ul>
<li>two arguments and each contains comma separated list: <code>.name(1, 2, 3; something, else)</code></li>
<li>three arguments and each contains one number: <code>.name(1, 2, 3)</code></li>
<li>use a dummy semicolon to create a mixin call with one argument containing a comma-separated css list: <code>.name(1, 2, 3;)</code>. <em>Note: if the trailing semi-colon seems strange, you may prefer: <code>.name(~(1, 2, 3))</code></em></li>
<li>Ways to write a comma separated default value:<ul>
<li><code>@param-values: red, blue; .name(@param1: @param-values)</code>.</li>
<li><code>.name(@param1: red, blue;)</code></li>
<li><code>.name(@param1: ~(red, blue))</code></li>
</ul>
</li>
</ul>
<h4 id="mixins-feature-overloading-mixins" class="docs-heading"><span class="anchor-target" id="mixins-feature-overloading-mixins"></span>
<a href="#mixins-feature-overloading-mixins" name="mixins-feature-overloading-mixins" class="anchor glyphicon glyphicon-link"></a>Overloading mixins</h4>
<p>It is legal to define multiple mixins with the same name and number of parameters. Less will use properties of all that can apply. If you used the mixin with one parameter e.g. <code>.mixin(green);</code>, then properties of all mixins with exactly one mandatory parameter will be used:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@color</span>) {
  <span class="hljs-attribute">color-1</span>: <span class="hljs-variable">@color</span>;
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@color</span>, <span class="hljs-variable">@padding</span>: <span class="hljs-number">2</span>) {
  <span class="hljs-attribute">color-2</span>: <span class="hljs-variable">@color</span>;
  <span class="hljs-attribute">padding-2</span>: <span class="hljs-variable">@padding</span>;
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@color</span>, <span class="hljs-variable">@padding</span>, <span class="hljs-variable">@margin</span>: <span class="hljs-number">2</span>) {
  <span class="hljs-attribute">color-3</span>: <span class="hljs-variable">@color</span>;
  <span class="hljs-attribute">padding-3</span>: <span class="hljs-variable">@padding</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-variable">@margin</span> <span class="hljs-variable">@margin</span> <span class="hljs-variable">@margin</span> <span class="hljs-variable">@margin</span>;
}
<span class="hljs-class">.some</span> <span class="hljs-class">.selector</span> <span class="hljs-tag">div</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-hexcolor">#008000</span>);
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-class">.some</span> <span class="hljs-class">.selector</span> <span class="hljs-tag">div</span> {
  <span class="hljs-attribute">color-1</span>: <span class="hljs-hexcolor">#008000</span>;
  <span class="hljs-attribute">color-2</span>: <span class="hljs-hexcolor">#008000</span>;
  <span class="hljs-attribute">padding-2</span>: <span class="hljs-number">2</span>;
}
</code></pre>
<h4 id="mixins-feature-named-parameters" class="docs-heading"><span class="anchor-target" id="mixins-feature-named-parameters"></span>
<a href="#mixins-feature-named-parameters" name="mixins-feature-named-parameters" class="anchor glyphicon glyphicon-link"></a>Named Parameters</h4>
<p>A mixin reference can supply parameters values by their names instead of just positions. Any parameter can be referenced by its name and they do not have to be in any special order:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@color</span>: black; <span class="hljs-variable">@margin</span>: <span class="hljs-number">10px</span>; <span class="hljs-variable">@padding</span>: <span class="hljs-number">20px</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-variable">@margin</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-variable">@padding</span>;
}
<span class="hljs-class">.class1</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-variable">@margin</span>: <span class="hljs-number">20px</span>; <span class="hljs-variable">@color</span>: <span class="hljs-hexcolor">#33acfe</span>);
}
<span class="hljs-class">.class2</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-hexcolor">#efca44</span>; <span class="hljs-variable">@padding</span>: <span class="hljs-number">40px</span>);
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-class">.class1</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#33acfe</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
}
<span class="hljs-class">.class2</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#efca44</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">40px</span>;
}
</code></pre>
<h4 id="mixins-feature-the-arguments-variable" class="docs-heading"><span class="anchor-target" id="mixins-feature-the-arguments-variable"></span>
<a href="#mixins-feature-the-arguments-variable" name="mixins-feature-the-arguments-variable" class="anchor glyphicon glyphicon-link"></a>The <code>@arguments</code> Variable</h4>
<p><code>@arguments</code> has a special meaning inside mixins, it contains all the arguments passed, when the mixin was called. This is useful if you don&apos;t want to deal with individual parameters:</p>
<pre><code class="lang-less"><span class="hljs-class">.box-shadow</span>(<span class="hljs-variable">@x</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">@y</span>: <span class="hljs-number">0</span>, <span class="hljs-variable">@blur</span>: <span class="hljs-number">1px</span>, <span class="hljs-variable">@color</span>: <span class="hljs-hexcolor">#000</span>) {
  <span class="hljs-attribute">-webkit-box-shadow</span>: <span class="hljs-variable">@arguments</span>;
     <span class="hljs-attribute">-moz-box-shadow</span>: <span class="hljs-variable">@arguments</span>;
          <span class="hljs-attribute">box-shadow</span>: <span class="hljs-variable">@arguments</span>;
}
<span class="hljs-class">.big-block</span> {
  <span class="hljs-class">.box-shadow</span>(<span class="hljs-number">2px</span>, <span class="hljs-number">5px</span>);
}
</code></pre>
<p>Which results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.big-block</span> {
  <span class="hljs-attribute">-webkit-box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">1px</span> <span class="hljs-hexcolor">#000</span>;
     <span class="hljs-attribute">-moz-box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">1px</span> <span class="hljs-hexcolor">#000</span>;
          <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">1px</span> <span class="hljs-hexcolor">#000</span>;
}
</code></pre>
<h4 id="mixins-feature-advanced-arguments-and-the-rest-variable" class="docs-heading"><span class="anchor-target" id="mixins-feature-advanced-arguments-and-the-rest-variable"></span>
<a href="#mixins-feature-advanced-arguments-and-the-rest-variable" name="mixins-feature-advanced-arguments-and-the-rest-variable" class="anchor glyphicon glyphicon-link"></a>Advanced Arguments and the <code>@rest</code> Variable</h4>
<p>You can use <code>...</code> if you want your mixin to take a variable number of arguments. Using this after a variable name will assign those arguments to the variable.</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(...) {        <span class="hljs-comment">// matches 0-N arguments</span>
<span class="hljs-class">.mixin</span>() {           <span class="hljs-comment">// matches exactly 0 arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>: <span class="hljs-number">1</span>) {      <span class="hljs-comment">// matches 0-1 arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>: <span class="hljs-number">1</span>, ...) { <span class="hljs-comment">// matches 0-N arguments</span>
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>, ...) {    <span class="hljs-comment">// matches 1-N arguments</span>
</code></pre>
<p>Furthermore:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>, <span class="hljs-variable">@rest</span>...) {
   <span class="hljs-comment">// @rest is bound to arguments after @a</span>
   <span class="hljs-comment">// @arguments is bound to all arguments</span>
}
</code></pre>
<h2 id="mixins-feature-pattern-matching" class="docs-heading"><span class="anchor-target" id="mixins-feature-pattern-matching"></span>
<a href="#mixins-feature-pattern-matching" name="mixins-feature-pattern-matching" class="anchor glyphicon glyphicon-link"></a>Pattern-matching</h2>
<p>Sometimes, you may want to change the behavior of a mixin, based on the parameters you pass to it. Let&apos;s start with something basic:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@s</span>, <span class="hljs-variable">@color</span>) { ... }

<span class="hljs-class">.class</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-variable">@switch</span>, <span class="hljs-hexcolor">#888</span>);
}
</code></pre>
<p>Now let&apos;s say we want <code>.mixin</code> to behave differently, based on the value of <code>@switch</code>, we could define <code>.mixin</code> as such:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(dark, <span class="hljs-variable">@color</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-function">darken</span>(<span class="hljs-variable">@color</span>, <span class="hljs-number">10%</span>);
}
<span class="hljs-class">.mixin</span>(light, <span class="hljs-variable">@color</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-function">lighten</span>(<span class="hljs-variable">@color</span>, <span class="hljs-number">10%</span>);
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@_</span>, <span class="hljs-variable">@color</span>) {
  <span class="hljs-attribute">display</span>: block;
}
</code></pre>
<p>Now, if we run:</p>
<pre><code class="lang-less"><span class="hljs-variable">@switch:</span> light;

<span class="hljs-class">.class</span> {
  <span class="hljs-class">.mixin</span>(<span class="hljs-variable">@switch</span>, <span class="hljs-hexcolor">#888</span>);
}
</code></pre>
<p>We will get the following CSS:</p>
<pre><code class="lang-css"><span class="hljs-class">.class</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#a2a2a2</span>;
  <span class="hljs-attribute">display</span>: block;
}
</code></pre>
<p>Where the color passed to <code>.mixin</code> was lightened. If the value of <code>@switch</code> was <code>dark</code>,
the result would be a darker color.</p>
<p>Here&apos;s what happened:</p>
<ul>
<li>The first mixin definition didn&apos;t match because it expected <code>dark</code> as the first argument.</li>
<li>The second mixin definition matched, because it expected <code>light</code>.</li>
<li>The third mixin definition matched because it expected any value.</li>
</ul>
<p>Only mixin definitions which matched were used. Variables match and bind to any value.
Anything other than a variable matches only with a value equal to itself.</p>
<p>We can also match on arity, here&apos;s an example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@a</span>;
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>, <span class="hljs-variable">@b</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-function">fade</span>(<span class="hljs-variable">@a</span>, <span class="hljs-variable">@b</span>);
}
</code></pre>
<p>Now if we call <code>.mixin</code> with a single argument, we will get the output of the first definition,
but if we call it with <em>two</em> arguments, we will get the second definition, namely <code>@a</code> faded to <code>@b</code>.</p>


          <br>
        </div>
      
    

      <!-- Using Mixins as Functions -->
      <h2 id="mixins-feature-mixins-as-functions-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature-mixins-as-functions-feature"></span>
<a href="#mixins-feature-mixins-as-functions-feature" name="mixins-feature-mixins-as-functions-feature" class="anchor glyphicon glyphicon-link"></a>Using Mixins as Functions</h2>
      
      
        <div class="section-content">
          
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixins-as-functions.md" data-content="mixins-as-functionsmd" target="_blank"></a>



<a id="mixins-as-functionsmd" href="https://github.com/less/less-docs/blob/master/content/features/mixins-as-functions.md" target="_blank">Edit the markdown source for &quot;mixins-as-functions&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


          <!-- mixins-as-functions -->
           


          <blockquote>
<p>Selecting properties and variables from mixin calls</p>
</blockquote>
<h4 id="mixins-feature-property-value-accessors" class="docs-heading"><span class="anchor-target" id="mixins-feature-property-value-accessors"></span>
<a href="#mixins-feature-property-value-accessors" name="mixins-feature-property-value-accessors" class="anchor glyphicon glyphicon-link"></a>Property / value accessors</h4>
<p><em>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v3.5.0</a></em></p>
<p>Starting in Less 3.5, you can use property/variable accessors to select a value from an evaluated mixin&apos;s rules. This can allow you to use mixins similar to functions.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.average</span>(<span class="hljs-variable">@x</span>, <span class="hljs-variable">@y</span>) {
  <span class="hljs-variable">@result:</span> ((<span class="hljs-variable">@x</span> + <span class="hljs-variable">@y</span>) / <span class="hljs-number">2</span>);
}

<span class="hljs-tag">div</span> {
  <span class="hljs-comment">// call a mixin and look up its &quot;@result&quot; value</span>
  <span class="hljs-attribute">padding</span>: .<span class="hljs-function">average</span>(<span class="hljs-number">16px</span>, <span class="hljs-number">50px</span>)[<span class="hljs-variable">@result</span>];
}
</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-tag">div</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">33px</span>;
}
</code></pre>
<h4 id="mixins-feature-overriding-mixin-values" class="docs-heading"><span class="anchor-target" id="mixins-feature-overriding-mixin-values"></span>
<a href="#mixins-feature-overriding-mixin-values" name="mixins-feature-overriding-mixin-values" class="anchor glyphicon glyphicon-link"></a>Overriding mixin values</h4>
<p>If you have multiple matching mixins, all rules are evaluated and merged, and the last matching value with that identifier is returned. This is similar to the cascade in CSS, and it allows you to &quot;override&quot; mixin values.</p>
<pre><code class="lang-less"><span class="hljs-comment">// library.less</span>
<span class="hljs-id">#library</span>() {
  <span class="hljs-class">.mixin</span>() {
    <span class="hljs-attribute">prop</span>: foo;
  }
}

<span class="hljs-comment">// customize.less</span>
<span class="hljs-at_rule">@import</span> <span class="hljs-string">&quot;library&quot;</span>;
<span class="hljs-id">#library</span>() {
  <span class="hljs-class">.mixin</span>() {
    <span class="hljs-attribute">prop</span>: bar;
  }
}

<span class="hljs-class">.box</span> {
  <span class="hljs-attribute">my-value</span>: #library.mixin[prop];
}
</code></pre>
<p>Outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.box</span> {
  <span class="hljs-attribute">my-value</span>: bar;
}
</code></pre>
<h4 id="mixins-feature-unnamed-lookups" class="docs-heading"><span class="anchor-target" id="mixins-feature-unnamed-lookups"></span>
<a href="#mixins-feature-unnamed-lookups" name="mixins-feature-unnamed-lookups" class="anchor glyphicon glyphicon-link"></a>Unnamed lookups</h4>
<p>If you don&apos;t specify a lookup value in <code>[@lookup]</code> and instead write <code>[]</code> after a mixin or ruleset call, <em>all</em> values will cascade and the last declared value will be selected.</p>
<p>Meaning: the averaging mixin from the above example could be written as:</p>
<pre><code class="lang-less"><span class="hljs-class">.average</span>(<span class="hljs-variable">@x</span>, <span class="hljs-variable">@y</span>) {
  <span class="hljs-variable">@result:</span> ((<span class="hljs-variable">@x</span> + <span class="hljs-variable">@y</span>) / <span class="hljs-number">2</span>);
}

<span class="hljs-tag">div</span> {
  <span class="hljs-comment">// call a mixin and look up its final value</span>
  <span class="hljs-attribute">padding</span>: .<span class="hljs-function">average</span>(<span class="hljs-number">16px</span>, <span class="hljs-number">50px</span>)[];
}
</code></pre>
<p>The output is the same:</p>
<pre><code class="lang-css"><span class="hljs-tag">div</span> {
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">33px</span>;
}
</code></pre>
<p>The same cascading behavior is true for rulesets or variables aliased to mixin calls.</p>
<pre><code class="lang-less"><span class="hljs-variable">@dr:</span> {
  <span class="hljs-attribute">value</span>: foo;
}
.box {
  <span class="hljs-attribute">my-value</span>: <span class="hljs-variable">@dr</span>[];
}
</code></pre>
<p>This outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.box</span> {
  <span class="hljs-attribute">my-value</span>: foo;
}
</code></pre>
<h4 id="mixins-feature-unlocking-mixins-variables-into-caller-scope" class="docs-heading"><span class="anchor-target" id="mixins-feature-unlocking-mixins-variables-into-caller-scope"></span>
<a href="#mixins-feature-unlocking-mixins-variables-into-caller-scope" name="mixins-feature-unlocking-mixins-variables-into-caller-scope" class="anchor glyphicon glyphicon-link"></a>Unlocking mixins &amp; variables into caller scope</h4>
<p><strong><em>DEPRECATED - Use Property / Value Accessors</em></strong></p>
<p>Variables and mixins defined in a mixin are visible and can be used in caller&apos;s scope. There is only one exception: a variable is not copied if the caller contains a variable with the same name (that includes variables defined by another mixin call).  Only variables present in callers local scope are protected. Variables inherited from parent scopes are overridden.</p>
<p><em>Note: this behavior is deprecated, and in the future, variables and mixins will not be merged into the caller scope in this way.</em></p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-variable">@width:</span>  <span class="hljs-number">100%</span>;
  <span class="hljs-variable">@height:</span> <span class="hljs-number">200px</span>;
}

<span class="hljs-class">.caller</span> {
  <span class="hljs-class">.mixin</span>();
  <span class="hljs-attribute">width</span>:  <span class="hljs-variable">@width</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>;
}

</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.caller</span> {
  <span class="hljs-attribute">width</span>:  <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
}
</code></pre>
<p>Variables defined directly in callers scope cannot be overridden. However, variables defined in callers parent scope is not protected and will be overridden:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>() {
  <span class="hljs-variable">@size:</span> in-mixin;
  <span class="hljs-variable">@definedOnlyInMixin:</span> in-mixin;
}

<span class="hljs-class">.class</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-variable">@size</span> <span class="hljs-variable">@definedOnlyInMixin</span>;
  <span class="hljs-class">.mixin</span>();
}

<span class="hljs-variable">@size:</span> globaly-defined-value; <span class="hljs-comment">// callers parent scope - no protection</span>
</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.class</span> {
  <span class="hljs-attribute">margin</span>: in-mixin in-mixin;
}
</code></pre>
<p>Finally, mixin defined in mixin acts as return value too:</p>
<pre><code class="lang-less"><span class="hljs-class">.unlock</span>(<span class="hljs-variable">@value</span>) { <span class="hljs-comment">// outer mixin</span>
  <span class="hljs-class">.doSomething</span>() { <span class="hljs-comment">// nested mixin</span>
    <span class="hljs-attribute">declaration</span>: <span class="hljs-variable">@value</span>;
  }
}

<span class="hljs-id">#namespace</span> {
  <span class="hljs-class">.unlock</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// unlock doSomething mixin</span>
  <span class="hljs-class">.doSomething</span>(); <span class="hljs-comment">//nested mixin was copied here and is usable</span>
}
</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-id">#namespace</span> {
  <span class="hljs-attribute">declaration</span>: <span class="hljs-number">5</span>;
}
</code></pre>


          <br>
        </div>
      
    

      <!-- Recursive Mixins -->
      <h2 id="mixins-feature-loops-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature-loops-feature"></span>
<a href="#mixins-feature-loops-feature" name="mixins-feature-loops-feature" class="anchor glyphicon glyphicon-link"></a>Recursive Mixins</h2>
      
      
        <div class="section-content">
          
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixin-loops.md" data-content="mixin-loopsmd" target="_blank"></a>



<a id="mixin-loopsmd" href="https://github.com/less/less-docs/blob/master/content/features/mixin-loops.md" target="_blank">Edit the markdown source for &quot;mixin-loops&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


          <!-- mixin-loops -->
           


          <blockquote>
<p>Creating loops</p>
</blockquote>
<p>In Less a mixin can call itself. Such recursive mixins, when combined with <a href="#mixin-guards-feature">Guard Expressions</a> and <a href="#mixins-parametric-feature-pattern-matching">Pattern Matching</a>, can be used to create various iterative/loop structures.</p>
<p>Example:</p>
<pre><code class="lang-less"><span class="hljs-class">.loop</span>(<span class="hljs-variable">@counter</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@counter</span> &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-class">.loop</span>((<span class="hljs-variable">@counter</span> - <span class="hljs-number">1</span>));    <span class="hljs-comment">// next iteration</span>
  <span class="hljs-attribute">width</span>: (<span class="hljs-number">10px</span> * <span class="hljs-variable">@counter</span>); <span class="hljs-comment">// code for each iteration</span>
}

<span class="hljs-tag">div</span> {
  <span class="hljs-class">.loop</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// launch the loop</span>
}
</code></pre>
<p>Output:</p>
<pre><code class="lang-css"><span class="hljs-tag">div</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">30px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
}
</code></pre>
<p>A generic example of using a recursive loop to generate CSS grid classes:</p>
<pre><code class="lang-less"><span class="hljs-class">.generate-columns</span>(<span class="hljs-number">4</span>);

<span class="hljs-class">.generate-columns</span>(<span class="hljs-variable">@n</span>, <span class="hljs-variable">@i</span>: <span class="hljs-number">1</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@i</span> =&lt; <span class="hljs-variable">@n</span>) {
  <span class="hljs-class">.column-@{i}</span> {
    <span class="hljs-attribute">width</span>: (<span class="hljs-variable">@i</span> * <span class="hljs-number">100%</span> / <span class="hljs-variable">@n</span>);
  }
  <span class="hljs-class">.generate-columns</span>(<span class="hljs-variable">@n</span>, (<span class="hljs-variable">@i</span> + <span class="hljs-number">1</span>));
}
</code></pre>
<p>Output:</p>
<pre><code class="lang-css"><span class="hljs-class">.column-1</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">25%</span>;
}
<span class="hljs-class">.column-2</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;
}
<span class="hljs-class">.column-3</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">75%</span>;
}
<span class="hljs-class">.column-4</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
}
</code></pre>


          <br>
        </div>
      
    

      <!-- Mixin Guards -->
      <h2 id="mixins-feature-mixin-guards-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature-mixin-guards-feature"></span>
<a href="#mixins-feature-mixin-guards-feature" name="mixins-feature-mixin-guards-feature" class="anchor glyphicon glyphicon-link"></a>Mixin Guards</h2>
      
      
        <div class="section-content">
          
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixin-guards.md" data-content="mixin-guardsmd" target="_blank"></a>



<a id="mixin-guardsmd" href="https://github.com/less/less-docs/blob/master/content/features/mixin-guards.md" target="_blank">Edit the markdown source for &quot;mixin-guards&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


          <!-- mixin-guards -->
           


          <p>Guards are useful when you want to match on <em>expressions</em>, as opposed to simple values or arity. If you are familiar with functional programming, you have probably encountered them already.</p>
<p>In trying to stay as close as possible to the declarative nature of CSS, Less has opted to implement conditional execution via <strong>guarded mixins</strong> instead of <code>if</code>/<code>else</code> statements, in the vein of <code>@media</code> query feature specifications.</p>
<p>Let&apos;s start with an example:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-function">lightness</span>(<span class="hljs-variable">@a</span>) &gt;= <span class="hljs-number">50%</span>) {
  <span class="hljs-attribute">background-color</span>: black;
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-function">lightness</span>(<span class="hljs-variable">@a</span>) &lt; <span class="hljs-number">50%</span>) {
  <span class="hljs-attribute">background-color</span>: white;
}
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@a</span>;
}
</code></pre>
<p>The key is the <code>when</code> keyword, which introduces a guard sequence (here with only one guard). Now if we run the following code:</p>
<pre><code class="lang-less"><span class="hljs-class">.class1</span> { <span class="hljs-class">.mixin</span>(<span class="hljs-hexcolor">#ddd</span>) }
<span class="hljs-class">.class2</span> { <span class="hljs-class">.mixin</span>(<span class="hljs-hexcolor">#555</span>) }
</code></pre>
<p>Here&apos;s what we&apos;ll get:</p>
<pre><code class="lang-css"><span class="hljs-class">.class1</span> {
  <span class="hljs-attribute">background-color</span>: black;
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#ddd</span>;
}
<span class="hljs-class">.class2</span> {
  <span class="hljs-attribute">background-color</span>: white;
  <span class="hljs-attribute">color</span>: <span class="hljs-hexcolor">#555</span>;
}
</code></pre>
<h4 id="mixins-feature-guard-comparison-operators" class="docs-heading"><span class="anchor-target" id="mixins-feature-guard-comparison-operators"></span>
<a href="#mixins-feature-guard-comparison-operators" name="mixins-feature-guard-comparison-operators" class="anchor glyphicon glyphicon-link"></a>Guard Comparison Operators</h4>
<p>The full list of comparison operators usable in guards are: <code>&gt;</code>, <code>&gt;=</code>, <code>=</code>, <code>=&lt;</code>, <code>&lt;</code>. Additionally, the keyword <code>true</code> is the only truthy value, making these two mixins equivalent:</p>
<pre><code class="lang-less"><span class="hljs-class">.truth</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@a</span>) { ... }
<span class="hljs-class">.truth</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@a</span> = true) { ... }
</code></pre>
<p>Any value other than the keyword <code>true</code> is falsy:</p>
<pre><code class="lang-less"><span class="hljs-class">.class</span> {
  <span class="hljs-class">.truth</span>(<span class="hljs-number">40</span>); <span class="hljs-comment">// Will not match any of the above definitions.</span>
}
</code></pre>
<p>Note that you can also compare arguments with each other, or with non-arguments:</p>
<pre><code class="lang-less"><span class="hljs-at_rule">@media</span>: mobile;

<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@media</span> = mobile) { ... }
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@media</span> = desktop) { ... }

<span class="hljs-class">.max</span>(<span class="hljs-variable">@a</span>; <span class="hljs-variable">@b</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@a</span> &gt; <span class="hljs-variable">@b</span>) { <span class="hljs-attribute">width</span>: <span class="hljs-variable">@a</span> }
<span class="hljs-class">.max</span>(<span class="hljs-variable">@a</span>; <span class="hljs-variable">@b</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@a</span> &lt; <span class="hljs-variable">@b</span>) { <span class="hljs-attribute">width</span>: <span class="hljs-variable">@b</span> }
</code></pre>
<h4 id="mixins-feature-guard-logical-operators" class="docs-heading"><span class="anchor-target" id="mixins-feature-guard-logical-operators"></span>
<a href="#mixins-feature-guard-logical-operators" name="mixins-feature-guard-logical-operators" class="anchor glyphicon glyphicon-link"></a>Guard Logical Operators</h4>
<p>You can use logical operators with guards. The syntax is based on CSS media queries.</p>
<p>Use the <code>and</code> keyword to combine guards:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-function">isnumber</span>(<span class="hljs-variable">@a</span>)) <span class="hljs-keyword">and</span> (<span class="hljs-variable">@a</span> &gt; <span class="hljs-number">0</span>) { ... }
</code></pre>
<p>You can emulate the <em>or</em> operator by separating guards with a comma <code>,</code>. If any of the guards evaluate to true, it&apos;s considered a match:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>) <span class="hljs-keyword">when</span> (<span class="hljs-variable">@a</span> &gt; <span class="hljs-number">10</span>), (<span class="hljs-variable">@a</span> &lt; -<span class="hljs-number">10</span>) { ... }
</code></pre>
<p>Use the <code>not</code> keyword to negate conditions:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@b</span>) <span class="hljs-keyword">when</span> <span class="hljs-keyword">not</span> (<span class="hljs-variable">@b</span> &gt; <span class="hljs-number">0</span>) { ... }
</code></pre>
<h4 id="mixins-feature-type-checking-functions" class="docs-heading"><span class="anchor-target" id="mixins-feature-type-checking-functions"></span>
<a href="#mixins-feature-type-checking-functions" name="mixins-feature-type-checking-functions" class="anchor glyphicon glyphicon-link"></a>Type Checking Functions</h4>
<p>Lastly, if you want to match mixins based on value type, you can use the <code>is</code> functions:</p>
<pre><code class="lang-less"><span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>; <span class="hljs-variable">@b</span>: <span class="hljs-number">0</span>) <span class="hljs-keyword">when</span> (<span class="hljs-function">isnumber</span>(<span class="hljs-variable">@b</span>)) { ... }
<span class="hljs-class">.mixin</span>(<span class="hljs-variable">@a</span>; <span class="hljs-variable">@b</span>: black) <span class="hljs-keyword">when</span> (<span class="hljs-function">iscolor</span>(<span class="hljs-variable">@b</span>)) { ... }
</code></pre>
<p>Here are the basic type checking functions:</p>
<ul>
<li><code>iscolor</code></li>
<li><code>isnumber</code></li>
<li><code>isstring</code></li>
<li><code>iskeyword</code></li>
<li><code>isurl</code></li>
</ul>
<p>If you want to check if a value is in a specific unit in addition to being a number, you may use one of:</p>
<ul>
<li><code>ispixel</code></li>
<li><code>ispercentage</code></li>
<li><code>isem</code></li>
<li><code>isunit</code></li>
</ul>


          <br>
        </div>
      
    

      <!-- Aliasing Mixins -->
      <h2 id="mixins-feature-mixin-aliasing-feature" class="docs-heading"><span class="anchor-target" id="mixins-feature-mixin-aliasing-feature"></span>
<a href="#mixins-feature-mixin-aliasing-feature" name="mixins-feature-mixin-aliasing-feature" class="anchor glyphicon glyphicon-link"></a>Aliasing Mixins</h2>
      
      
        <div class="section-content">
          
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/mixins-aliasing.md" data-content="mixins-aliasingmd" target="_blank"></a>



<a id="mixins-aliasingmd" href="https://github.com/less/less-docs/blob/master/content/features/mixins-aliasing.md" target="_blank">Edit the markdown source for &quot;mixins-aliasing&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


          <!-- mixins-aliasing -->
           


          <p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v3.5.0</a></p>
<blockquote>
<p>Assigning mixin calls to a variable</p>
</blockquote>
<p>Mixins can be assigned to a variable to be called as a variable call, or can be used for map lookup.</p>
<pre><code class="lang-less"><span class="hljs-id">#theme</span><span class="hljs-class">.dark</span><span class="hljs-class">.navbar</span> {
  <span class="hljs-class">.colors</span>(light) {
    <span class="hljs-attribute">primary</span>: purple;
  }
  <span class="hljs-class">.colors</span>(dark) {
    <span class="hljs-attribute">primary</span>: black;
    <span class="hljs-attribute">secondary</span>: grey;
  }
}

<span class="hljs-class">.navbar</span> {
  <span class="hljs-variable">@colors:</span> #theme.dark.navbar.<span class="hljs-function">colors</span>(dark);
  <span class="hljs-attribute">background</span>: <span class="hljs-variable">@colors</span>[primary];
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-variable">@colors</span>[secondary];
}
</code></pre>
<p>This would output:</p>
<pre><code class="lang-css"><span class="hljs-class">.navbar</span> {
  <span class="hljs-attribute">background</span>: black;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid grey;
}
</code></pre>
<h4 id="mixins-feature-variable-calls" class="docs-heading"><span class="anchor-target" id="mixins-feature-variable-calls"></span>
<a href="#mixins-feature-variable-calls" name="mixins-feature-variable-calls" class="anchor glyphicon glyphicon-link"></a>Variable calls</h4>
<p>Entire mixin calls can be aliased and called as variable calls. As in:</p>
<pre><code class="lang-less"><span class="hljs-id">#library</span>() {
  <span class="hljs-class">.colors</span>() {
    <span class="hljs-attribute">background</span>: green;
  }
}
<span class="hljs-class">.box</span> {
  <span class="hljs-variable">@alias:</span> #library.<span class="hljs-function">colors</span>();
  <span class="hljs-variable">@alias</span>();
}
</code></pre>
<p>Outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.box</span> {
  <span class="hljs-attribute">background</span>: green;
}
</code></pre>
<p>Note, unlike mixins used in root, mixin calls assigned to variables and <em>called with no arguments</em> always require parentheses. The following is not valid.</p>
<pre><code class="lang-less"><span class="hljs-id">#library</span>() {
  <span class="hljs-class">.colors</span>() {
    <span class="hljs-attribute">background</span>: green;
  }
}
<span class="hljs-class">.box</span> {
  <span class="hljs-variable">@alias:</span> #library.colors;
  <span class="hljs-variable">@alias</span>();   <span class="hljs-comment">// ERROR: Could not evaluate variable call @alias</span>
}
</code></pre>
<p>This is because it&apos;s ambiguous if variable is assigned a list of selectors or a mixin call. For example, in Less 3.5+, this variable could be used this way.</p>
<pre><code class="lang-less"><span class="hljs-class">.box</span> {
  <span class="hljs-variable">@alias:</span> #library.colors;
  <span class="hljs-variable">@{alias}</span> {
    <span class="hljs-attribute">a</span>: b;
  }
}
</code></pre>
<p>The above would output:</p>
<pre><code class="lang-css"><span class="hljs-class">.box</span> <span class="hljs-id">#library</span><span class="hljs-class">.colors</span> {
  <span class="hljs-attribute">a</span>: b;
}
</code></pre>


          <br>
        </div>
      
    

  </div>

  <!-- Detached Rulesets -->
  <div class="docs-section">
    
    <h1 id="detached-rulesets-feature" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature"></span>
<a href="#detached-rulesets-feature" name="detached-rulesets-feature" class="anchor glyphicon glyphicon-link"></a>Detached Rulesets</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/detached-rulesets.md" data-content="detached-rulesetsmd" target="_blank"></a>



<a id="detached-rulesetsmd" href="https://github.com/less/less-docs/blob/master/content/features/detached-rulesets.md" target="_blank">Edit the markdown source for &quot;detached-rulesets&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- detached-rulesets -->
         


        <blockquote>
<p>Assign a ruleset to a variable</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.7.0</a></p>
<p>A detached ruleset is a group of css properties, nested rulesets, media declarations or anything else stored in a variable. You can include it into a ruleset or another structure and all its properties are going to be copied there. You can also use it as a mixin argument and pass it around as any other variable.</p>
<p>Simple example:</p>
<pre><code class="lang-less"><span class="hljs-comment">// declare detached ruleset</span>
<span class="hljs-variable">@detached-ruleset:</span> { <span class="hljs-attribute">background</span>: red; }; <span class="hljs-comment">// semi-colon is optional in 3.5.0+</span>

<span class="hljs-comment">// use detached ruleset</span>
<span class="hljs-class">.top</span> {
    <span class="hljs-variable">@detached-ruleset</span>(); 
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-class">.top</span> {
  <span class="hljs-attribute">background</span>: red;
}
</code></pre>
<p>Parentheses after a detached ruleset call are mandatory (except when followed by a <a href="#detached-rulesets-feature-property-variable-accessors">lookup value</a>). The call <code>@detached-ruleset;</code> would not work.</p>
<p>It is useful when you want to define a mixin that abstracts out either wrapping a piece of code in a media query or a non-supported browser class name. The rulesets can be passed to mixin so that the mixin can wrap the content, e.g.</p>
<pre><code class="lang-less"><span class="hljs-class">.desktop-and-old-ie</span>(<span class="hljs-variable">@rules</span>) {
  <span class="hljs-at_rule">@media</span> screen and (min-width: <span class="hljs-number">1200px</span>) { <span class="hljs-variable">@rules</span>(); }
  <span class="hljs-tag">html</span><span class="hljs-class">.lt-ie9</span> <span class="hljs-keyword">&amp;</span>                         { <span class="hljs-variable">@rules</span>(); }
}

<span class="hljs-tag">header</span> {
  <span class="hljs-attribute">background-color</span>: blue;

  <span class="hljs-class">.desktop-and-old-ie</span>({
    <span class="hljs-attribute">background-color</span>: red;
  });
}
</code></pre>
<p>Here the <code>desktop-and-old-ie</code> mixin defines the media query and root class so that you can use a mixin to wrap a piece of code. This will output</p>
<pre><code class="lang-css"><span class="hljs-tag">header</span> {
  <span class="hljs-attribute">background-color</span>: blue;
}
<span class="hljs-at_rule">@media</span> screen and (min-width: <span class="hljs-number">1200px</span>) {
  <span class="hljs-tag">header</span> {
    <span class="hljs-attribute">background-color</span>: red;
  }
}
<span class="hljs-tag">html</span><span class="hljs-class">.lt-ie9</span> <span class="hljs-tag">header</span> {
  <span class="hljs-attribute">background-color</span>: red;
}
</code></pre>
<p>A ruleset can be now assigned to a variable or passed in to a mixin and can contain the full set of Less features, e.g.</p>
<pre><code class="lang-less"><span class="hljs-variable">@my-ruleset:</span> {
    <span class="hljs-class">.my-selector</span> {
      <span class="hljs-attribute">background-color</span>: black;
    }
  };
</code></pre>
<p>You can even take advantage of <a href="#features-overview-feature-media-query-bubbling-and-nested-media-queries">media query bubbling</a>, for instance</p>
<pre><code class="lang-less"><span class="hljs-variable">@my-ruleset:</span> {
    <span class="hljs-class">.my-selector</span> {
      <span class="hljs-at_rule">@media</span> tv {
        <span class="hljs-attribute">background-color</span>: black;
      }
    }
  };
<span class="hljs-at_rule">@media</span> (orientation:portrait) {
    <span class="hljs-variable">@my-ruleset</span>();
}
</code></pre>
<p>which will output</p>
<pre><code class="lang-css"><span class="hljs-at_rule">@media</span> (orientation: portrait) and tv {
  <span class="hljs-class">.my-selector</span> {
    <span class="hljs-attribute">background-color</span>: black;
  }
}
</code></pre>
<p>A detached ruleset call unlocks (returns) all its mixins into caller the same way as mixin calls do. However, it does <strong>not</strong> return variables.</p>
<p>Returned mixin:</p>
<pre><code class="lang-less"><span class="hljs-comment">// detached ruleset with a mixin</span>
<span class="hljs-variable">@detached-ruleset:</span> { 
    <span class="hljs-class">.mixin</span>() {
        <span class="hljs-attribute">color</span>: blue;
    }
};
<span class="hljs-comment">// call detached ruleset</span>
<span class="hljs-class">.caller</span> {
    <span class="hljs-variable">@detached-ruleset</span>(); 
    <span class="hljs-class">.mixin</span>();
}
</code></pre>
<p>Results in:</p>
<pre><code class="lang-css"><span class="hljs-class">.caller</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<p>Private variables:</p>
<pre><code class="lang-less"><span class="hljs-variable">@detached-ruleset:</span> { 
    <span class="hljs-variable">@color:</span>blue; <span class="hljs-comment">// this variable is private</span>
};
<span class="hljs-class">.caller</span> {
    <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>; <span class="hljs-comment">// syntax error</span>
}
</code></pre>
<h2 id="detached-rulesets-feature-scoping" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-scoping"></span>
<a href="#detached-rulesets-feature-scoping" name="detached-rulesets-feature-scoping" class="anchor glyphicon glyphicon-link"></a>Scoping</h2>
<p>A detached ruleset can use all variables and mixins accessible where it is <em>defined</em> and where it is <em>called</em>. Otherwise said, both definition and caller scopes are available to it. If both scopes contains the same variable or mixin, declaration scope value takes precedence. </p>
<p><em>Declaration scope</em> is the one where detached ruleset body is defined. Copying a detached ruleset from one variable into another cannot modify its scope. The ruleset does not gain access to new scopes just by being referenced there.</p>
<p>Lastly, a detached ruleset can gain access to scope by being unlocked (imported) into it.</p>
<p><em>Note: unlocking variables into scope via a called mixin is deprecated. Use <a href="#detached-rulesets-feature-property-variable-accessors">property / variable accessors</a>.</em></p>
<h4 id="detached-rulesets-feature-definition-and-caller-scope-visibility" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-definition-and-caller-scope-visibility"></span>
<a href="#detached-rulesets-feature-definition-and-caller-scope-visibility" name="detached-rulesets-feature-definition-and-caller-scope-visibility" class="anchor glyphicon glyphicon-link"></a>Definition and Caller Scope Visibility</h4>
<p>A detached ruleset sees the caller&apos;s variables and mixins:</p>
<pre><code class="lang-less"><span class="hljs-variable">@detached-ruleset:</span> {
  <span class="hljs-attribute">caller-variable</span>: <span class="hljs-variable">@caller-variable</span>; <span class="hljs-comment">// variable is undefined here</span>
  <span class="hljs-class">.caller-mixin</span>(); <span class="hljs-comment">// mixin is undefined here</span>
};

<span class="hljs-tag">selector</span> {
  <span class="hljs-comment">// use detached ruleset</span>
  <span class="hljs-variable">@detached-ruleset</span>(); 

  <span class="hljs-comment">// define variable and mixin needed inside the detached ruleset</span>
  <span class="hljs-variable">@caller-variable:</span> value;
  <span class="hljs-class">.caller-mixin</span>() {
    <span class="hljs-attribute">variable</span>: declaration;
  }
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-tag">selector</span> {
  <span class="hljs-attribute">caller-variable</span>: value;
  <span class="hljs-attribute">variable</span>: declaration;
}
</code></pre>
<p>Variable and mixins accessible from definition win over those available in the caller:</p>
<pre><code class="lang-less"><span class="hljs-variable">@variable:</span> global;
<span class="hljs-variable">@detached-ruleset:</span> {
  <span class="hljs-comment">// will use global variable, because it is accessible</span>
  <span class="hljs-comment">// from detached-ruleset definition</span>
  <span class="hljs-attribute">variable</span>: <span class="hljs-variable">@variable</span>; 
};

<span class="hljs-tag">selector</span> {
  <span class="hljs-variable">@detached-ruleset</span>();
  <span class="hljs-variable">@variable:</span> value; <span class="hljs-comment">// variable defined in caller - will be ignored</span>
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-tag">selector</span> {
  <span class="hljs-attribute">variable</span>: global;
}
</code></pre>
<h4 id="detached-rulesets-feature-referencing-won-t-modify-detached-ruleset-scope" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-referencing-won-t-modify-detached-ruleset-scope"></span>
<a href="#detached-rulesets-feature-referencing-won-t-modify-detached-ruleset-scope" name="detached-rulesets-feature-referencing-won-t-modify-detached-ruleset-scope" class="anchor glyphicon glyphicon-link"></a>Referencing <em>Won&apos;t</em> Modify Detached Ruleset Scope</h4>
<p>A ruleset does not gain access to new scopes just by being referenced there:</p>
<pre><code class="lang-less"><span class="hljs-variable">@detached-1:</span> { <span class="hljs-attribute">scope-detached</span>: <span class="hljs-variable">@one</span> <span class="hljs-variable">@two</span>; };
<span class="hljs-class">.one</span> {
  <span class="hljs-variable">@one:</span> visible;
  <span class="hljs-class">.two</span> {
    <span class="hljs-variable">@detached-2:</span> <span class="hljs-variable">@detached-1</span>; <span class="hljs-comment">// copying/renaming ruleset </span>
    <span class="hljs-variable">@two:</span> visible; <span class="hljs-comment">// ruleset can not see this variable</span>
  }
}

<span class="hljs-class">.use-place</span> {
  <span class="hljs-class">.one</span> &gt; <span class="hljs-class">.two</span>(); 
  <span class="hljs-variable">@detached-2</span>();
}
</code></pre>
<p>throws an error:</p>
<pre><code>ERROR 1:32 The variable &quot;@one&quot; was not declared.
</code></pre><h4 id="detached-rulesets-feature-unlocking-will-modify-detached-ruleset-scope" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-unlocking-will-modify-detached-ruleset-scope"></span>
<a href="#detached-rulesets-feature-unlocking-will-modify-detached-ruleset-scope" name="detached-rulesets-feature-unlocking-will-modify-detached-ruleset-scope" class="anchor glyphicon glyphicon-link"></a>Unlocking <em>Will</em> Modify Detached Ruleset Scope</h4>
<p>A detached ruleset gains access by being unlocked (imported) inside a scope:</p>
<pre><code class="lang-less"><span class="hljs-id">#space</span> {
  <span class="hljs-class">.importer-1</span>() {
    <span class="hljs-variable">@detached:</span> { <span class="hljs-attribute">scope-detached</span>: <span class="hljs-variable">@variable</span>; }; <span class="hljs-comment">// define detached ruleset</span>
  }
}

<span class="hljs-class">.importer-2</span>() {
  <span class="hljs-variable">@variable:</span> value; <span class="hljs-comment">// unlocked detached ruleset CAN see this variable</span>
  <span class="hljs-id">#space</span> &gt; <span class="hljs-class">.importer-1</span>(); <span class="hljs-comment">// unlock/import detached ruleset</span>
}

<span class="hljs-class">.use-place</span> {
  <span class="hljs-class">.importer-2</span>(); <span class="hljs-comment">// unlock/import detached ruleset second time</span>
   <span class="hljs-variable">@detached</span>();
}
</code></pre>
<p>compiles into:</p>
<pre><code class="lang-css"><span class="hljs-class">.use-place</span> {
  <span class="hljs-attribute">scope-detached</span>: value;
}
</code></pre>
<h2 id="detached-rulesets-feature-property-variable-accessors" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-property-variable-accessors"></span>
<a href="#detached-rulesets-feature-property-variable-accessors" name="detached-rulesets-feature-property-variable-accessors" class="anchor glyphicon glyphicon-link"></a>Property / variable accessors</h2>
<h4 id="detached-rulesets-feature--lookup-values-" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature--lookup-values-"></span>
<a href="#detached-rulesets-feature--lookup-values-" name="detached-rulesets-feature--lookup-values-" class="anchor glyphicon glyphicon-link"></a>(Lookup values)</h4>
<p><em>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v3.5.0</a></em></p>
<p>Starting in Less 3.5, you can use property/variable accessors (also called &quot;lookups&quot;) to select a value from variable (detached) rulesets.</p>
<pre><code class="lang-less"><span class="hljs-variable">@config:</span> {
  <span class="hljs-attribute">option1</span>: true;
  <span class="hljs-attribute">option2</span>: false;
}

.<span class="hljs-function">mixin</span>() when (<span class="hljs-variable">@config</span>[option1] = true) {
  <span class="hljs-attribute">selected</span>: value;
}

.box {
  <span class="hljs-class">.mixin</span>();
}
</code></pre>
<p>Outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.box</span> {
  <span class="hljs-attribute">selected</span>: value;
}
</code></pre>
<p>If what is returned from a lookup is another detached ruleset, you can use a second lookup to get that value.</p>
<pre><code class="lang-less"><span class="hljs-variable">@config:</span> {
  <span class="hljs-variable">@colors:</span> {
    <span class="hljs-attribute">primary</span>: blue;
  }
}

.box {
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@config</span>[<span class="hljs-variable">@colors</span>][primary];
}
</code></pre>
<h4 id="detached-rulesets-feature-variable-variables-in-lookups" class="docs-heading"><span class="anchor-target" id="detached-rulesets-feature-variable-variables-in-lookups"></span>
<a href="#detached-rulesets-feature-variable-variables-in-lookups" name="detached-rulesets-feature-variable-variables-in-lookups" class="anchor glyphicon glyphicon-link"></a>Variable variables in lookups</h4>
<p>The lookup value that is returned can itself be variable. As in, you can write:</p>
<pre><code class="lang-less"><span class="hljs-variable">@config:</span> {
  <span class="hljs-variable">@dark:</span> {
    <span class="hljs-attribute">primary</span>: darkblue;
  }
  <span class="hljs-variable">@light</span>: {
    <span class="hljs-attribute">primary</span>: lightblue;
  }
}

.box {
  <span class="hljs-variable">@lookup:</span> dark;
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@config</span>[<span class="hljs-variable">@@lookup</span>][primary];
}
</code></pre>
<p>This will output:</p>
<pre><code class="lang-less"><span class="hljs-class">.box</span> {
  <span class="hljs-attribute">color</span>: darkblue;
}
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- Maps -->
  <div class="docs-section">
    
    <h1 id="maps-feature" class="docs-heading"><span class="anchor-target" id="maps-feature"></span>
<a href="#maps-feature" name="maps-feature" class="anchor glyphicon glyphicon-link"></a>Maps</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/maps.md" data-content="mapsmd" target="_blank"></a>



<a id="mapsmd" href="https://github.com/less/less-docs/blob/master/content/features/maps.md" target="_blank">Edit the markdown source for &quot;maps&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- maps -->
         


        <p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v3.5.0</a></p>
<blockquote>
<p>Use rulesets and mixins as maps of values</p>
</blockquote>
<p>By combining namespacing with the lookup <code>[]</code> syntax, you can turn your rulesets / mixins into maps.</p>
<pre><code class="lang-less"><span class="hljs-variable">@sizes:</span> {
  <span class="hljs-attribute">mobile</span>: <span class="hljs-number">320px</span>;
  <span class="hljs-attribute">tablet</span>: <span class="hljs-number">768px</span>;
  <span class="hljs-attribute">desktop</span>: <span class="hljs-number">1024px</span>;
}

.navbar {
  <span class="hljs-attribute">display</span>: block;

  <span class="hljs-at_rule">@media</span> (min-width: <span class="hljs-variable">@sizes</span>[tablet]) {
    <span class="hljs-attribute">display</span>: inline-block;
  }
}
</code></pre>
<p>Outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.navbar</span> {
  <span class="hljs-attribute">display</span>: block;
}
<span class="hljs-at_rule">@media</span> (min-width: <span class="hljs-number">768px</span>) {
  <span class="hljs-class">.navbar</span> {
    <span class="hljs-attribute">display</span>: inline-block;
  }
}
</code></pre>
<p>Mixins are a little more versatile as maps because of namespacing and the ability to overload mixins.</p>
<pre><code class="lang-less"><span class="hljs-id">#library</span>() {
  <span class="hljs-class">.colors</span>() {
    <span class="hljs-attribute">primary</span>: green;
    <span class="hljs-attribute">secondary</span>: blue;
  }
}

<span class="hljs-id">#library</span>() {
  <span class="hljs-class">.colors</span>() { <span class="hljs-attribute">primary</span>: grey; }
}

<span class="hljs-class">.button</span> {
  <span class="hljs-attribute">color</span>: #library.colors[primary];
  <span class="hljs-attribute">border-color</span>: #library.colors[secondary];
}
</code></pre>
<p>Outputs:</p>
<pre><code class="lang-css"><span class="hljs-class">.button</span> {
  <span class="hljs-attribute">color</span>: grey;
  <span class="hljs-attribute">border-color</span>: blue;
}
</code></pre>
<p>You can also make this easier by <a href="#mixins-feature-mixin-aliasing-feature">aliasing mixins</a>.  That is:</p>
<pre><code class="lang-less"><span class="hljs-class">.button</span> {
  <span class="hljs-variable">@colors:</span> #library.<span class="hljs-function">colors</span>();
  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@colors</span>[primary];
  <span class="hljs-attribute">border-color</span>: <span class="hljs-variable">@colors</span>[secondary];
}
</code></pre>
<p>Note, if a lookup value produces another ruleset, you can append a second <code>[]</code> lookup, as in:</p>
<pre><code class="lang-less"><span class="hljs-variable">@config:</span> {
  <span class="hljs-variable">@options:</span> {
    <span class="hljs-attribute">library-on</span>: true
  }
}

&amp; when (<span class="hljs-variable">@config</span>[<span class="hljs-variable">@options</span>][library-on] = true) {
  <span class="hljs-class">.produce-ruleset</span> {
    <span class="hljs-attribute">prop</span>: val;
  }
}
</code></pre>
<p>In this way, rulesets and variable calls can emulate a type of &quot;namespacing&quot;, similar to mixins.</p>
<p>As far as whether to use mixins or rulesets assigned to variables as maps, it&apos;s up to you. You may want to replace entire maps by re-declaring a variable assigned to a rulset. Or you may want to &quot;merge&quot; individual key/value pairs, in which case mixins as maps might be more appropriate.</p>
<h3 id="maps-feature-using-variable-variables-in-lookups" class="docs-heading"><span class="anchor-target" id="maps-feature-using-variable-variables-in-lookups"></span>
<a href="#maps-feature-using-variable-variables-in-lookups" name="maps-feature-using-variable-variables-in-lookups" class="anchor glyphicon glyphicon-link"></a>Using variable variables in lookups</h3>
<p>One important thing to notice is that the value in <code>[@lookup]</code> is the key (variable) name <code>@lookup</code>, and is not evaluated as a variable. If you want the key name itself to be variable, you can use the <code>@@variable</code> syntax.</p>
<p>E.g.</p>
<pre><code class="lang-less"><span class="hljs-class">.foods</span>() {
  <span class="hljs-variable">@dessert:</span> ice cream;
}

<span class="hljs-variable">@key-to-lookup:</span> dessert;

<span class="hljs-class">.lunch</span> {
  <span class="hljs-attribute">treat</span>: .foods[<span class="hljs-variable">@@key-to-lookup</span>];
}
</code></pre>
<p>This would output:</p>
<pre><code class="lang-css"><span class="hljs-class">.lunch</span> {
  <span class="hljs-attribute">treat</span>: ice cream;
}
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- Scope -->
  <div class="docs-section">
    
    <h1 id="scope-feature" class="docs-heading"><span class="anchor-target" id="scope-feature"></span>
<a href="#scope-feature" name="scope-feature" class="anchor glyphicon glyphicon-link"></a>Scope</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/scope.md" data-content="scopemd" target="_blank"></a>



<a id="scopemd" href="https://github.com/less/less-docs/blob/master/content/features/scope.md" target="_blank">Edit the markdown source for &quot;scope&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- scope -->
         


        <blockquote>
<p>Some additional scoping features of Less</p>
</blockquote>
<h2 id="scope-feature-mixin-scope-features" class="docs-heading"><span class="anchor-target" id="scope-feature-mixin-scope-features"></span>
<a href="#scope-feature-mixin-scope-features" name="scope-feature-mixin-scope-features" class="anchor glyphicon glyphicon-link"></a>Mixin scope features</h2>
<p>Intuitively, mixins have access to definition scope.</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-variable">@a:</span> one;
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop</span>: <span class="hljs-variable">@a</span>;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-id">#ns</span><span class="hljs-class">.mixin-1</span>();
}

<span class="hljs-comment">/* OUTPUTS:
.rule {
  prop: one;
}
*/</span>
</code></pre>
<h3 id="scope-feature-deprecated-mixin-scope-features" class="docs-heading"><span class="anchor-target" id="scope-feature-deprecated-mixin-scope-features"></span>
<a href="#scope-feature-deprecated-mixin-scope-features" name="scope-feature-deprecated-mixin-scope-features" class="anchor glyphicon glyphicon-link"></a>Deprecated mixin scope features</h3>
<p>This is a list of mixin scope features that may be removed in future releases.</p>
<h4 id="scope-feature--1-deprecated-mixins-have-access-to-caller-scope-" class="docs-heading"><span class="anchor-target" id="scope-feature--1-deprecated-mixins-have-access-to-caller-scope-"></span>
<a href="#scope-feature--1-deprecated-mixins-have-access-to-caller-scope-" name="scope-feature--1-deprecated-mixins-have-access-to-caller-scope-" class="anchor glyphicon glyphicon-link"></a>#1. (DEPRECATED) Mixins have access to caller scope.</h4>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop</span>: <span class="hljs-variable">@a</span>;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-variable">@a:</span> one;
  <span class="hljs-id">#ns</span><span class="hljs-class">.mixin-1</span>();
}
<span class="hljs-comment">/* OUTPUTS:
.rule {
  prop: one;
}
*/</span>
</code></pre>
<p>This is counter-intuitive because:</p>
<ol>
<li>It is not typical in most other languages.</li>
<li>It&apos;s not immediately obvious when looking at the definition what output will be produced by the mixin.</li>
</ol>
<p><strong>Preferred approach</strong>: Pass in the variable you want to be visible to the mixin.</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>(<span class="hljs-variable">@a</span>) {
    <span class="hljs-attribute">prop</span>: <span class="hljs-variable">@a</span>;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-id">#ns</span><span class="hljs-class">.mixin-1</span>(<span class="hljs-variable">@a</span>: one);
}
</code></pre>
<h4 id="scope-feature--2-deprecated-the-caller-scope-has-access-to-variables-from-the-mixin" class="docs-heading"><span class="anchor-target" id="scope-feature--2-deprecated-the-caller-scope-has-access-to-variables-from-the-mixin"></span>
<a href="#scope-feature--2-deprecated-the-caller-scope-has-access-to-variables-from-the-mixin" name="scope-feature--2-deprecated-the-caller-scope-has-access-to-variables-from-the-mixin" class="anchor glyphicon glyphicon-link"></a>#2. (DEPRECATED) The caller scope has access to variables from the mixin</h4>
<p>Mixins will push their variables into the caller scope, but <em>only</em> if the variable is not locally defined.</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-variable">@a:</span> one;
    <span class="hljs-variable">@b:</span> two;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-variable">@b:</span> three;
  <span class="hljs-id">#ns</span><span class="hljs-class">.mixin-1</span>();
  <span class="hljs-attribute">prop-1</span>: <span class="hljs-variable">@a</span>;
  <span class="hljs-attribute">prop-2</span>: <span class="hljs-variable">@b</span>;
}
<span class="hljs-comment">/* OUTPUTS:
.rule {
  prop-1: one;
  prop-2: three;
}
*/</span>
</code></pre>
<p>This is counter-intuitive because:</p>
<ol>
<li>A variable higher in the caller scope can be overridden.</li>
<li>It&apos;s also not a typical language behavior.</li>
<li>It differs from the behavior of detached rulesets.</li>
</ol>
<p>Also, with the introduction of Maps, you can retrieve variable values (and mixins) directly.</p>
<p><strong>Preferred approach</strong>:</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-variable">@a:</span> one;
    <span class="hljs-variable">@b:</span> two;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-variable">@returns:</span> #ns.<span class="hljs-function">mixin-1</span>();
  <span class="hljs-attribute">prop-1</span>: <span class="hljs-variable">@returns</span>[<span class="hljs-variable">@a</span>];
  <span class="hljs-attribute">prop-2</span>: <span class="hljs-variable">@returns</span>[<span class="hljs-variable">@b</span>];
}
<span class="hljs-comment">/* OUTPUTS:
.rule {
  prop-1: one;
  prop-2: two;
}
*/</span>
</code></pre>
<h4 id="scope-feature--3-deprecated-the-caller-scope-has-access-to-mixins-from-the-mixin" class="docs-heading"><span class="anchor-target" id="scope-feature--3-deprecated-the-caller-scope-has-access-to-mixins-from-the-mixin"></span>
<a href="#scope-feature--3-deprecated-the-caller-scope-has-access-to-mixins-from-the-mixin" name="scope-feature--3-deprecated-the-caller-scope-has-access-to-mixins-from-the-mixin" class="anchor glyphicon glyphicon-link"></a>#3. (DEPRECATED) The caller scope has access to mixins from the mixin</h4>
<p>Similarly to deprecated variable behavior, mixins are also pushed into the caller scope. However, unlike variables, mixins with the same name as the merged scope mixin are merged.</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop-1</span>: one;
    <span class="hljs-attribute">prop-2</span>: two;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-id">#ns</span>();
  <span class="hljs-class">.mixin-1</span>();
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop-3</span>: three;
  }
}
<span class="hljs-comment">/* OUTPUT:
.rule {
  prop-1: one;
  prop-2: two;
  prop-3: three;
}
*/</span>
</code></pre>
<p><strong>Preferred approach</strong>: Call mixins directly.</p>
<pre><code class="lang-less"><span class="hljs-id">#ns</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop-1</span>: one;
    <span class="hljs-attribute">prop-2</span>: two;
  }
}
<span class="hljs-class">.rule</span> {
  <span class="hljs-class">.mixin-1</span>() {
    <span class="hljs-attribute">prop-3</span>: three;
  }
  <span class="hljs-id">#ns</span><span class="hljs-class">.mixin-1</span>();
  <span class="hljs-class">.mixin-1</span>();
}
<span class="hljs-comment">/* OUTPUT:
.rule {
  prop-1: one;
  prop-2: two;
  prop-3: three;
}
*/</span>
</code></pre>
<h2 id="scope-feature-tips-tricks" class="docs-heading"><span class="anchor-target" id="scope-feature-tips-tricks"></span>
<a href="#scope-feature-tips-tricks" name="scope-feature-tips-tricks" class="anchor glyphicon glyphicon-link"></a>Tips &amp; Tricks</h2>
<p>Credit: <a href="http://github.com/less/less.js/issues/1472#issuecomment-22213697">less/less.js/issues/1472</a></p>
<p>Here is a trick for defining variables and keeping them in some private scope, preventing them from leaking to the global space.</p>
<pre><code class="lang-less"><span class="hljs-keyword">&amp;</span> {
  <span class="hljs-comment">// Vars</span>
  <span class="hljs-variable">@height:</span> <span class="hljs-number">100px</span>;
  <span class="hljs-variable">@width:</span> <span class="hljs-number">20px</span>;
  <span class="hljs-comment">// Don&apos;t define any prop:value on this scope (as doing so will generate (wrong) output).</span>

  <span class="hljs-class">.test</span> {
    <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span>;
  }
}

<span class="hljs-class">.rest</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>; <span class="hljs-comment">// Name error: variable @height is undefined</span>
}
</code></pre>
<p>Here, <code>@height</code> and <code>@width</code> are only defined for the scope created by <code>&amp; { ... }</code> You can also nest an scope inside a rule:</p>
<pre><code class="lang-less"><span class="hljs-class">.some-module</span> {
  <span class="hljs-variable">@height:</span> <span class="hljs-number">200px</span>;
  <span class="hljs-variable">@width:</span> <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">text-align</span>: left;
  <span class="hljs-attribute">line-height</span>: <span class="hljs-variable">@height</span>; <span class="hljs-comment">// 200px</span>

  <span class="hljs-keyword">&amp;</span> {
    <span class="hljs-comment">// Override original values</span>
    <span class="hljs-variable">@height:</span> <span class="hljs-number">100px</span>;
    <span class="hljs-variable">@width:</span> auto;

    <span class="hljs-class">.some-module__element</span> {
      <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>; <span class="hljs-comment">// 100px</span>
      <span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span>; <span class="hljs-comment">// 200px</span>
    }

    <span class="hljs-class">.some-module__element</span> <span class="hljs-class">.text</span> {
      <span class="hljs-attribute">line-height</span>: (<span class="hljs-variable">@height</span> / <span class="hljs-number">2</span>); <span class="hljs-comment">// 50px</span>
    }
  }

  <span class="hljs-keyword">&amp;</span> {
    <span class="hljs-comment">// Override original values</span>
    <span class="hljs-variable">@height:</span> <span class="hljs-number">50px</span>;

    <span class="hljs-class">.some-module__another-element</span> {
      <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>; <span class="hljs-comment">// 50px</span>
      <span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span>; <span class="hljs-comment">// 200px</span>
    }

    <span class="hljs-class">.some-module__another-element</span> <span class="hljs-class">.text</span> {
      <span class="hljs-attribute">line-height</span>: (<span class="hljs-variable">@height</span> / <span class="hljs-number">2</span>); <span class="hljs-comment">// 25px</span>
    }
  }
}
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- CSS Guards -->
  <div class="docs-section">
    
    <h1 id="css-guards-feature" class="docs-heading"><span class="anchor-target" id="css-guards-feature"></span>
<a href="#css-guards-feature" name="css-guards-feature" class="anchor glyphicon glyphicon-link"></a>CSS Guards</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/css-guards.md" data-content="css-guardsmd" target="_blank"></a>



<a id="css-guardsmd" href="https://github.com/less/less-docs/blob/master/content/features/css-guards.md" target="_blank">Edit the markdown source for &quot;css-guards&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- css-guards -->
         


        <blockquote>
<p>&quot;if&quot;&apos;s around selectors</p>
</blockquote>
<p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v1.5.0</a></p>
<p>Like Mixin Guards, guards can also be applied to css selectors, which is syntactic sugar for declaring the mixin and then calling it immediately.</p>
<p>For instance, before 1.5.0 you would have had to do this:</p>
<pre><code class="lang-less"><span class="hljs-class">.my-optional-style</span>() <span class="hljs-keyword">when</span> (<span class="hljs-variable">@my-option</span> = true) {
  <span class="hljs-tag">button</span> {
    <span class="hljs-attribute">color</span>: white;
  }
}
<span class="hljs-class">.my-optional-style</span>();
</code></pre>
<p>Now, you can apply the guard directly to a style.</p>
<pre><code class="lang-less"><span class="hljs-tag">button</span> <span class="hljs-keyword">when</span> (<span class="hljs-variable">@my-option</span> = true) {
  <span class="hljs-attribute">color</span>: white;
}
</code></pre>
<p>You can also achieve an <code>if</code> type statement by combining this with the <code>&amp;</code> feature, allowing you to group multiple guards. </p>
<pre><code class="lang-less"><span class="hljs-keyword">&amp;</span> <span class="hljs-keyword">when</span> (<span class="hljs-variable">@my-option</span> = true) {
  <span class="hljs-tag">button</span> {
    <span class="hljs-attribute">color</span>: white;
  }
  <span class="hljs-tag">a</span> {
    <span class="hljs-attribute">color</span>: blue;
  }
}
</code></pre>
<p>Note that you can also achieve a similar pattern by using the actual <code>if()</code> function and a variable call. As in:</p>
<pre><code class="lang-less"><span class="hljs-variable">@dr:</span> <span class="hljs-function">if</span>(<span class="hljs-variable">@my-option</span> = true, {
  <span class="hljs-tag">button</span> {
    <span class="hljs-attribute">color</span>: white;
  }
  a {
    <span class="hljs-attribute">color</span>: blue;
  }
});
<span class="hljs-variable">@dr</span>();
</code></pre>


        <br>
      </div>
    

    

  </div>

  <!-- @plugin At-Rules -->
  <div class="docs-section">
    
    <h1 id="plugin-atrules-feature" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature"></span>
<a href="#plugin-atrules-feature" name="plugin-atrules-feature" class="anchor glyphicon glyphicon-link"></a>@plugin At-Rules</h1>
    

    
      
      <div class="section-content">
        
<a class="glyphicon glyphicon-pencil source-link right" href="https://github.com/less/less-docs/blob/master/content/features/plugins.md" data-content="pluginsmd" target="_blank"></a>



<a id="pluginsmd" href="https://github.com/less/less-docs/blob/master/content/features/plugins.md" target="_blank">Edit the markdown source for &quot;plugins&quot;
  <span class="glyphicon glyphicon-new-window"></span>
</a>


        <!-- plugins -->
         


        <p>Released <a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">v2.5.0</a></p>
<blockquote>
<p>Import JavaScript plugins to add Less.js functions and features</p>
</blockquote>
<h2 id="plugin-atrules-feature-writing-your-first-plugin" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature-writing-your-first-plugin"></span>
<a href="#plugin-atrules-feature-writing-your-first-plugin" name="plugin-atrules-feature-writing-your-first-plugin" class="anchor glyphicon glyphicon-link"></a>Writing your first plugin</h2>
<p>Using a <code>@plugin</code> at-rule is similar to using an <code>@import</code> for your <code>.less</code> files.</p>
<pre><code class="lang-less"><span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;my-plugin&quot;</span>;  <span class="hljs-comment">// automatically appends .js if no extension</span>
</code></pre>
<p>Since Less plugins are evaluated within the Less scope, the plugin definition can be quite simple.</p>
<pre><code class="lang-js">registerPlugin({
    <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">less, pluginManager, functions</span>) </span>{
        functions.add(<span class="hljs-string">&apos;pi&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI;
        });
    }
})
</code></pre>
<p>or you can use <code>module.exports</code> (shimmed to work in browser as well as Node.js).</p>
<pre><code class="lang-js"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">less, pluginManager, functions</span>) </span>{
        functions.add(<span class="hljs-string">&apos;pi&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI;
        });
    }
};
</code></pre>
<p>Note that other Node.js CommonJS conventions, like <code>require()</code> are not available in the browser. Keep this in mind when writing cross-platform plugins.</p>
<p>What can you do with a plugin? A lot, but let&apos;s start with the basics. We&apos;ll focus first on what you might put inside the <code>install</code> function. Let&apos;s say you write this:</p>
<pre><code class="lang-js"><span class="hljs-comment">// my-plugin.js</span>
<span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">less, pluginManager, functions</span>) </span>{
    functions.add(<span class="hljs-string">&apos;pi&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.PI;
    });
}
<span class="hljs-comment">// etc</span>
</code></pre>
<p>Congratulations! You&apos;ve written a Less plugin! </p>
<p>If you were to use this in your stylesheet:</p>
<pre><code class="lang-less"><span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;my-plugin&quot;</span>;
<span class="hljs-class">.show-me-pi</span> {
  <span class="hljs-attribute">value</span>: <span class="hljs-function">pi</span>();
}
</code></pre>
<p>You would get:</p>
<pre><code class="lang-less"><span class="hljs-class">.show-me-pi</span> {
  <span class="hljs-attribute">value</span>: <span class="hljs-number">3.141592653589793</span>;
}
</code></pre>
<p>However, you would need to return a proper Less node if you wanted to, say, multiply that against other values or do other Less operations. Otherwise the output in your stylesheet is plain text (which may be fine for your purposes).</p>
<p>Meaning, this is more correct:</p>
<pre><code class="lang-js">functions.add(<span class="hljs-string">&apos;pi&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> tree.Dimension(<span class="hljs-built_in">Math</span>.PI);
});
</code></pre>
<p><em>Note: A dimension is a number with or without a unit, like &quot;10px&quot;, which would be <code>less.Dimension(10, &quot;px&quot;)</code>. For a list of units, see the <a href="TODO">Less API</a>.</em></p>
<p>Now you can use your function in operations.</p>
<pre><code class="lang-less"><span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;my-plugin&quot;</span>;
<span class="hljs-class">.show-me-pi</span> {
  <span class="hljs-attribute">value</span>: <span class="hljs-function">pi</span>() * <span class="hljs-number">2</span>;
}
</code></pre>
<p>You may have noticed that there are available globals for your plugin file, namely a function registry (<code>functions</code> object), and the <code>less</code> object. These are there for convenience.</p>
<h2 id="plugin-atrules-feature-plugin-scope" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature-plugin-scope"></span>
<a href="#plugin-atrules-feature-plugin-scope" name="plugin-atrules-feature-plugin-scope" class="anchor glyphicon glyphicon-link"></a>Plugin Scope</h2>
<p>Functions added by a <code>@plugin</code> at-rule adheres to Less scoping rules. This is great for Less library authors that want to add functionality without introducing naming conflicts.</p>
<p>For instance, say you have 2 plugins from two third-party libraries that both have a function named &quot;foo&quot;.</p>
<pre><code class="lang-js"><span class="hljs-comment">// lib1.js</span>
<span class="hljs-comment">// ...</span>
    functions.add(<span class="hljs-string">&apos;foo&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;foo&quot;</span>;
    });
<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// lib2.js</span>
<span class="hljs-comment">// ...</span>
    functions.add(<span class="hljs-string">&apos;foo&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bar&quot;</span>;
    });
<span class="hljs-comment">// ...</span>
</code></pre>
<p>That&apos;s ok! You can choose which library&apos;s function creates which output.</p>
<pre><code class="lang-less"><span class="hljs-class">.el-1</span> {
    <span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;lib1&quot;</span>;
    <span class="hljs-attribute">value</span>: <span class="hljs-function">foo</span>();
}
<span class="hljs-class">.el-2</span> {
    <span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;lib2&quot;</span>;
    <span class="hljs-attribute">value</span>: <span class="hljs-function">foo</span>();
}
</code></pre>
<p>This will produce:</p>
<pre><code class="lang-less"><span class="hljs-class">.el-1</span> {
    <span class="hljs-attribute">value</span>: foo;
}
<span class="hljs-class">.el-2</span> {
    <span class="hljs-attribute">value</span>: bar;
}
</code></pre>
<p>For plugin authors sharing their plugins, that means you can also effectively make private functions by placing them in a particular scope. As in, this will cause an error:</p>
<pre><code class="lang-less"><span class="hljs-class">.el</span> {
    <span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;lib1&quot;</span>;
}
<span class="hljs-variable">@value:</span> <span class="hljs-function">foo</span>();
</code></pre>
<p>As of Less 3.0, functions can return any kind of Node type, and can be called at any level.</p>
<p>Meaning, this would throw an error in 2.x, as functions had to be part of the value of a property or variable assignment:</p>
<pre><code class="lang-less"><span class="hljs-class">.block</span> {
    <span class="hljs-attribute">color</span>: blue;
    <span class="hljs-attribute">my-function-rules</span>();
}
</code></pre>
<p>In 3.x, that&apos;s no longer the case, and functions can return At-Rules, Rulesets, any other Less node, strings, and numbers (the latter two are converted to Anonymous nodes).</p>
<h2 id="plugin-atrules-feature-null-functions" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature-null-functions"></span>
<a href="#plugin-atrules-feature-null-functions" name="plugin-atrules-feature-null-functions" class="anchor glyphicon glyphicon-link"></a>Null Functions</h2>
<p>There are times when you may want to call a function, but you don&apos;t want anything output (such as storing a value for later use). In that case, you just need to return <code>false</code> from the function.</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> collection = [];

functions.add(<span class="hljs-string">&apos;store&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
    collection.push(val);  <span class="hljs-comment">// imma store this for later</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});
</code></pre>
<pre><code class="lang-less"><span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;collections&quot;</span>;
<span class="hljs-variable">@var:</span> <span class="hljs-number">32</span>;
<span class="hljs-attribute">store</span>(<span class="hljs-variable">@var</span>);
</code></pre>
<p>Later you could do something like:</p>
<pre><code class="lang-js">functions.add(<span class="hljs-string">&apos;retrieve&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> tree.Value(collection);
});
</code></pre>
<pre><code class="lang-less"><span class="hljs-class">.get-my-values</span> {
    <span class="hljs-variable">@plugin</span> <span class="hljs-string">&quot;collections&quot;</span>;
    <span class="hljs-attribute">values</span>: <span class="hljs-function">retrieve</span>();   
}
</code></pre>
<h2 id="plugin-atrules-feature-the-less-js-plugin-object" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature-the-less-js-plugin-object"></span>
<a href="#plugin-atrules-feature-the-less-js-plugin-object" name="plugin-atrules-feature-the-less-js-plugin-object" class="anchor glyphicon glyphicon-link"></a>The Less.js Plugin Object</h2>
<p>A Less.js plugin should export an object that has one or more of these properties.</p>
<pre><code class="lang-js">{
    <span class="hljs-comment">/* Called immediately after the plugin is 
     * first imported, only once. */</span>
    <span class="hljs-attr">install</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">less, pluginManager, functions</span>) </span>{ },

    <span class="hljs-comment">/* Called for each instance of your @plugin. */</span>
    <span class="hljs-attr">use</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{ },

    <span class="hljs-comment">/* Called for each instance of your @plugin, 
     * when rules are being evaluated.
     * It&apos;s just later in the evaluation lifecycle */</span>
    <span class="hljs-attr">eval</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{ },

    <span class="hljs-comment">/* Passes an arbitrary string to your plugin 
     * e.g. @plugin (args) &quot;file&quot;;
     * This string is not parsed for you, 
     * so it can contain (almost) anything */</span>
    <span class="hljs-attr">setOptions</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">argumentString</span>) </span>{ },

    <span class="hljs-comment">/* Set a minimum Less compatibility string
     * You can also use an array, as in [3, 0] */</span>
    <span class="hljs-attr">minVersion</span>: [<span class="hljs-string">&apos;3.0&apos;</span>],

    <span class="hljs-comment">/* Used for lessc only, to explain 
     * options in a Terminal */</span>
    <span class="hljs-attr">printUsage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ },

}
</code></pre>
<p>The PluginManager instance for the <code>install()</code> function provides methods for adding visitors, file managers, and post-processors.</p>
<p>Here are some example repos showing the different plugin types. <!-- TODO: updated examples --></p>
<ul>
<li>post-processor: <a href="https://github.com/less/less-plugin-clean-css">https://github.com/less/less-plugin-clean-css</a></li>
<li>visitor: <a href="https://github.com/less/less-plugin-inline-urls">https://github.com/less/less-plugin-inline-urls</a></li>
<li>file-manager: <a href="https://github.com/less/less-plugin-npm-import">https://github.com/less/less-plugin-npm-import</a></li>
</ul>
<h2 id="plugin-atrules-feature-pre-loaded-plugins" class="docs-heading"><span class="anchor-target" id="plugin-atrules-feature-pre-loaded-plugins"></span>
<a href="#plugin-atrules-feature-pre-loaded-plugins" name="plugin-atrules-feature-pre-loaded-plugins" class="anchor glyphicon glyphicon-link"></a>Pre-Loaded Plugins</h2>
<p>While a <code>@plugin</code> call works well for most scenarios, there are times when you might want to load a plugin before parsing starts.</p>
<p>See: <a href="../usage/#plugins">Pre-Loaded Plugins</a> in the &quot;Using Less.js&quot; section for how to do that.</p>


        <br>
      </div>
    

    

  </div>

</div>
        </div>
      </div>
    </div>

    
    <footer class="footer" role="contentinfo">
  <div class="container">
    <div class="bs-social">
  <ul class="bs-social-buttons">
    <li>
      <iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=less&amp;repo=less.js&amp;type=watch&amp;count=true" width="100" height="20" title="Star on GitHub"></iframe>
    </li>
    <li>
      <iframe class="github-btn" src="https://ghbtns.com/github-btn.html?user=less&amp;repo=less.js&amp;type=fork&amp;count=true" width="102" height="20" title="Fork on GitHub"></iframe>
    </li>
  </ul>
</div>

    <p>Less and these docs are maintained by <a href="../about/#team">the core Less team</a>.</p>
    <p>Documentation source code released under the <a href="https://github.com/less/less-docs/blob/master/LICENSE-MIT" target="_blank">MIT License</a>, documentation under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.</p>
    <ul class="footer-links">
      <li>Currently v4.1.3</li>
      
      <li class="muted">&#xB7;</li>
      <li><a href="https://github.com/less/less.js/issues">Less Language and Compiler Issues</a></li>
      <li class="muted">&#xB7;</li>
      <li><a href="https://github.com/less/less-docs/issues?&amp;state=open">Less Docs Issues</a></li>
      <li class="muted">&#xB7;</li>
      <li><a href="https://github.com/less/less.js/blob/master/CHANGELOG.md">Changelog</a></li>
      
    </ul>
  </div>
</footer>


    
    <!-- Core JavaScript
================================================== -->
<!-- Placed at the end of the document so the pages load faster -->
<script src="https://fastly.jsdelivr.net/npm/@docsearch/js@3"></script>
<script type="text/javascript">
  docsearch({
    appId: 'LELS6COOLE',
    apiKey: 'ad081396555d043318b6a9af4f27a9ec',
    indexName: 'lesscss',
    container: '#docsearch',
    debug: false // Set debug to true if you want to inspect the modal
  });
</script>
<script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/holder/2.2.0/holder.min.js"></script>
<script src="../public/js/application.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics 4 (GA4) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0LBC5XBD1L"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0LBC5XBD1L');
</script>



  </body>
</html>